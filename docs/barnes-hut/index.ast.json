{
  "metadata": {
    "output": {
      "api": true,
      "ast": {
        "space": "2"
      },
      "html": {
        "selfContained": true,
        "styles": "styles.css"
      }
    },
    "section-numbers": false,
    "title": "The Barnes-Hut Approximation: Efficient computation of N-body forces"
  },
  "article": {
    "type": "component",
    "name": "article",
    "children": [
      {
        "type": "component",
        "name": "cell-view",
        "properties": {
          "hide": {
            "type": "value",
            "value": "true"
          }
        },
        "children": [
          {
            "type": "textnode",
            "value": "charge = -30\n---\nstep = 0\n---\naccum = 0\n---\ntheta = 0\n---\nfocus = -1\n---\nlayout = true\n---\nestimate = false"
          }
        ]
      },
      {
        "type": "component",
        "name": "aside",
        "properties": {
          "class": {
            "type": "value",
            "value": "margin sticky barnes-hut"
          }
        },
        "children": [
          {
            "type": "component",
            "name": "p",
            "children": [
              {
                "type": "component",
                "name": "barnes-hut",
                "properties": {
                  "width": {
                    "type": "value",
                    "value": "500"
                  },
                  "height": {
                    "type": "value",
                    "value": "500"
                  },
                  "size": {
                    "type": "expression",
                    "value": "step"
                  },
                  "theta": {
                    "type": "expression",
                    "value": "theta"
                  },
                  "charge": {
                    "type": "expression",
                    "value": "charge"
                  },
                  "layout": {
                    "type": "expression",
                    "value": "layout && !estimate"
                  },
                  "estimate": {
                    "type": "expression",
                    "value": "estimate"
                  },
                  "accumulate": {
                    "type": "expression",
                    "value": "accum"
                  }
                }
              }
            ]
          }
        ]
      },
      {
        "type": "component",
        "name": "h1",
        "properties": {
          "id": {
            "type": "value",
            "value": "introduction"
          }
        },
        "children": [
          {
            "type": "textnode",
            "value": "Introduction"
          }
        ]
      },
      {
        "type": "component",
        "name": "p",
        "children": [
          {
            "type": "textnode",
            "value": "Computers are exciting tools for discovery, with which we can model and explore complex phenomena.\nFor example, to test theories about the formation of the universe, we can perform "
          },
          {
            "type": "component",
            "name": "em",
            "children": [
              {
                "type": "textnode",
                "value": "simulations"
              }
            ]
          },
          {
            "type": "textnode",
            "value": " to predict how galaxies evolve.\nWe could gather the estimated mass and location of stars and model their gravitational interactions over time."
          }
        ]
      },
      {
        "type": "component",
        "name": "p",
        "children": [
          {
            "type": "textnode",
            "value": "Another avenue for discovery is to "
          },
          {
            "type": "component",
            "name": "em",
            "children": [
              {
                "type": "textnode",
                "value": "visualize"
              }
            ]
          },
          {
            "type": "textnode",
            "value": " complex information to reveal structure and patterns.\nConsider this network diagram, showing connections between people in a social network. We can examine community groups and identify people who bridge between them."
          }
        ]
      },
      {
        "type": "component",
        "name": "p",
        "children": [
          {
            "type": "textnode",
            "value": "Though they may seem quite different at first, these two examples share a common need.\nThey both require computing forces that arise from pairwise interactions among a set of points, often referred to as an "
          },
          {
            "type": "component",
            "name": "em",
            "children": [
              {
                "type": "textnode",
                "value": "N-body problem"
              }
            ]
          },
          {
            "type": "textnode",
            "value": ".\nIn the case of astronomical simulation, we seek to model the gravitational forces among stars.\nIn the case of network visualization, we compute the layout using a similar physical simulation: nodes in the network act as charged particles that repel each other, links act as springs that pull related nodes together."
          }
        ]
      },
      {
        "type": "component",
        "name": "p",
        "children": [
          {
            "type": "component",
            "name": "em",
            "children": [
              {
                "type": "textnode",
                "value": "To get a sense of how this force-directed layout works, drag the nodes or use the slider to adjust the force strength."
              }
            ]
          },
          {
            "type": "textnode",
            "value": "\nNegative values indicate repulsive forces, while positive values indicate attractive forces."
          }
        ]
      },
      {
        "type": "component",
        "name": "cell-view",
        "properties": {
          "bind": {
            "type": "value",
            "value": "charge"
          }
        },
        "children": [
          {
            "type": "textnode",
            "value": "Inputs.range([-30, 10], { step: 1, label: 'Force Strength' })"
          }
        ]
      },
      {
        "type": "component",
        "name": "p",
        "children": [
          {
            "type": "textnode",
            "value": "A straightforward approach to computing N-body forces is to consider all pairs of individual points and add up the contributions of each interaction.\nThis na√Øve scheme has "
          },
          {
            "type": "component",
            "name": "em",
            "children": [
              {
                "type": "textnode",
                "value": "quadratic complexity"
              }
            ]
          },
          {
            "type": "textnode",
            "value": ": as the number of points "
          },
          {
            "type": "component",
            "name": "em",
            "children": [
              {
                "type": "textnode",
                "value": "n"
              }
            ]
          },
          {
            "type": "textnode",
            "value": " increases, the running time grows proportionally to "
          },
          {
            "type": "component",
            "name": "em",
            "children": [
              {
                "type": "textnode",
                "value": "n"
              }
            ]
          },
          {
            "type": "component",
            "name": "sup",
            "children": [
              {
                "type": "textnode",
                "value": "2"
              }
            ]
          },
          {
            "type": "textnode",
            "value": ", quickly leading to intractably long calculations.\nHow might we do better?"
          }
        ]
      },
      {
        "type": "component",
        "name": "h1",
        "properties": {
          "id": {
            "type": "value",
            "value": "the-barnes-hut-approximation"
          }
        },
        "children": [
          {
            "type": "textnode",
            "value": "The Barnes-Hut Approximation"
          }
        ]
      },
      {
        "type": "component",
        "name": "p",
        "children": [
          {
            "type": "textnode",
            "value": "To accelerate computation and make large-scale simulations possible, the astronomers Josh Barnes and Piet Hut devised a clever scheme: approximate long-range forces by replacing a group of distant points with their center of mass.\nIn exchange for a small amount of error, this scheme significantly speeds up calculation, with complexity "
          },
          {
            "type": "component",
            "name": "em",
            "children": [
              {
                "type": "textnode",
                "value": "n log n"
              }
            ]
          },
          {
            "type": "textnode",
            "value": " rather than "
          },
          {
            "type": "component",
            "name": "em",
            "children": [
              {
                "type": "textnode",
                "value": "n"
              }
            ]
          },
          {
            "type": "component",
            "name": "sup",
            "children": [
              {
                "type": "textnode",
                "value": "2"
              }
            ]
          },
          {
            "type": "textnode",
            "value": "."
          }
        ]
      },
      {
        "type": "component",
        "name": "p",
        "children": [
          {
            "type": "textnode",
            "value": "Central to this approximation is a "
          },
          {
            "type": "component",
            "name": "em",
            "children": [
              {
                "type": "textnode",
                "value": "spatial index"
              }
            ]
          },
          {
            "type": "textnode",
            "value": ": a "
          },
          {
            "type": "component",
            "name": "quote",
            "children": [
              {
                "type": "textnode",
                "value": "map"
              }
            ]
          },
          {
            "type": "textnode",
            "value": " of space that helps us model groups of points as a single center of mass.\nIn two dimensions, we use a "
          },
          {
            "type": "component",
            "name": "link",
            "properties": {
              "href": {
                "type": "value",
                "value": "https://en.wikipedia.org/wiki/Quadtree"
              }
            },
            "children": [
              {
                "type": "textnode",
                "value": "quadtree"
              }
            ]
          },
          {
            "type": "textnode",
            "value": " data structure, which subdivides square regions of space into four equal-sized quadrants.\n(In three dimensions, an "
          },
          {
            "type": "component",
            "name": "link",
            "properties": {
              "href": {
                "type": "value",
                "value": "https://en.wikipedia.org/wiki/Octree"
              }
            },
            "children": [
              {
                "type": "textnode",
                "value": "octree"
              }
            ]
          },
          {
            "type": "textnode",
            "value": " divides a cubic volume into eight sub-cubes.)"
          }
        ]
      },
      {
        "type": "component",
        "name": "p",
        "children": [
          {
            "type": "textnode",
            "value": "The Barnes-Hut approximation involves three steps:"
          }
        ]
      },
      {
        "type": "component",
        "name": "ol",
        "children": [
          {
            "type": "component",
            "name": "li",
            "children": [
              {
                "type": "textnode",
                "value": "Construct the spatial index (quadtree)"
              }
            ]
          },
          {
            "type": "component",
            "name": "li",
            "children": [
              {
                "type": "textnode",
                "value": "Calculate centers of mass"
              }
            ]
          },
          {
            "type": "component",
            "name": "li",
            "children": [
              {
                "type": "textnode",
                "value": "Estimate forces"
              }
            ]
          }
        ]
      },
      {
        "type": "component",
        "name": "p",
        "children": [
          {
            "type": "textnode",
            "value": "Let‚Äôs explore each step in turn.\nWe will assume we are computing "
          },
          {
            "type": "component",
            "name": "em",
            "children": [
              {
                "type": "textnode",
                "value": "repulsive"
              }
            ]
          },
          {
            "type": "textnode",
            "value": " forces for the purposes of network layout.\nThis setup is akin to modeling anti-gravity or electric forces with similarly-charged particles.\nWhile we will use the term "
          },
          {
            "type": "component",
            "name": "quote",
            "children": [
              {
                "type": "textnode",
                "value": "center of mass"
              }
            ]
          },
          {
            "type": "textnode",
            "value": ", this could readily be replaced with "
          },
          {
            "type": "component",
            "name": "quote",
            "children": [
              {
                "type": "textnode",
                "value": "center of charge"
              }
            ]
          },
          {
            "type": "textnode",
            "value": "."
          }
        ]
      },
      {
        "type": "component",
        "name": "p",
        "children": [
          {
            "type": "component",
            "name": "em",
            "children": [
              {
                "type": "textnode",
                "value": "As you read through, click the "
              },
              {
                "type": "component",
                "name": "link",
                "properties": {
                  "class": {
                    "type": "value",
                    "value": "action"
                  },
                  "click": {
                    "type": "event",
                    "value": "alert('üëç üéâ')"
                  }
                },
                "children": [
                  {
                    "type": "textnode",
                    "value": "action links"
                  }
                ]
              },
              {
                "type": "textnode",
                "value": " to update the diagram!"
              }
            ]
          }
        ]
      },
      {
        "type": "component",
        "name": "h2",
        "properties": {
          "id": {
            "type": "value",
            "value": "step-1-construct-the-quadtree"
          }
        },
        "children": [
          {
            "type": "textnode",
            "value": "Step 1: Construct the Quadtree"
          }
        ]
      },
      {
        "type": "component",
        "name": "p",
        "children": [
          {
            "type": "textnode",
            "value": "We begin with "
          },
          {
            "type": "component",
            "name": "link",
            "properties": {
              "class": {
                "type": "value",
                "value": "action"
              },
              "click": {
                "type": "event",
                "value": "layout=false, step=0"
              }
            },
            "children": [
              {
                "type": "textnode",
                "value": "a set of two-dimensional input points"
              }
            ]
          },
          {
            "type": "textnode",
            "value": ".\nWhen we "
          },
          {
            "type": "component",
            "name": "link",
            "properties": {
              "class": {
                "type": "value",
                "value": "action"
              },
              "click": {
                "type": "event",
                "value": "layout=false, step=1"
              }
            },
            "children": [
              {
                "type": "textnode",
                "value": "insert the first point into the quadtree"
              }
            ]
          },
          {
            "type": "textnode",
            "value": ", it is added to the top-level root cell of the tree."
          }
        ]
      },
      {
        "type": "component",
        "name": "p",
        "children": [
          {
            "type": "component",
            "name": "link",
            "properties": {
              "class": {
                "type": "value",
                "value": "action"
              },
              "click": {
                "type": "event",
                "value": "layout=false, step=2"
              }
            },
            "children": [
              {
                "type": "textnode",
                "value": "When we insert another point"
              }
            ]
          },
          {
            "type": "textnode",
            "value": ", the tree expands by subdiving the space.\nWith\n"
          },
          {
            "type": "component",
            "name": "link",
            "properties": {
              "class": {
                "type": "value",
                "value": "action"
              },
              "click": {
                "type": "event",
                "value": "layout=false, step=Math.min(step + 1, 77)"
              }
            },
            "children": [
              {
                "type": "textnode",
                "value": "each"
              }
            ]
          },
          {
            "type": "textnode",
            "value": "\n"
          },
          {
            "type": "component",
            "name": "link",
            "properties": {
              "class": {
                "type": "value",
                "value": "action"
              },
              "click": {
                "type": "event",
                "value": "layout=false, step=Math.min(step + 1, 77)"
              }
            },
            "children": [
              {
                "type": "textnode",
                "value": "subsequent"
              }
            ]
          },
          {
            "type": "textnode",
            "value": "\n"
          },
          {
            "type": "component",
            "name": "link",
            "properties": {
              "class": {
                "type": "value",
                "value": "action"
              },
              "click": {
                "type": "event",
                "value": "layout=false, step=Math.min(step + 1, 77)"
              }
            },
            "children": [
              {
                "type": "textnode",
                "value": "insertion"
              }
            ]
          },
          {
            "type": "textnode",
            "value": ",\nmore fine-grained cells are added until all points reside in their own cell."
          }
        ]
      },
      {
        "type": "component",
        "name": "p",
        "children": [
          {
            "type": "component",
            "name": "em",
            "children": [
              {
                "type": "textnode",
                "value": "Advance the slider to add each point and produce the full quadtree"
              }
            ]
          },
          {
            "type": "textnode",
            "value": "."
          }
        ]
      },
      {
        "type": "component",
        "name": "cell-view",
        "properties": {
          "bind": {
            "type": "value",
            "value": "step"
          }
        },
        "children": [
          {
            "type": "textnode",
            "value": "Inputs.range([0, 77], { step: 1, label: 'Inserted Points' })"
          }
        ]
      },
      {
        "type": "component",
        "name": "h2",
        "properties": {
          "id": {
            "type": "value",
            "value": "step-2-calculate-centers-of-mass"
          }
        },
        "children": [
          {
            "type": "textnode",
            "value": "Step 2: Calculate Centers of Mass"
          }
        ]
      },
      {
        "type": "component",
        "name": "p",
        "children": [
          {
            "type": "textnode",
            "value": "After quadtree construction, "
          },
          {
            "type": "component",
            "name": "link",
            "properties": {
              "class": {
                "type": "value",
                "value": "action"
              },
              "click": {
                "type": "event",
                "value": "layout=false, ++accum"
              }
            },
            "children": [
              {
                "type": "textnode",
                "value": "we calculate centers of mass for each cell of the tree"
              }
            ]
          },
          {
            "type": "textnode",
            "value": ".\nThe center of mass of a quadtree cell is the weighted average of the centers of its four child cells."
          }
        ]
      },
      {
        "type": "component",
        "name": "p",
        "children": [
          {
            "type": "textnode",
            "value": "We visit the leaf node cells first and then visit subsequent parent cells, merging data as we pass upwards through the tree.\nOnce the traversal completes, each cell has been updated with the position and strength of its center of mass."
          }
        ]
      },
      {
        "type": "component",
        "name": "h2",
        "properties": {
          "id": {
            "type": "value",
            "value": "step-3-estimate-n-body-forces"
          }
        },
        "children": [
          {
            "type": "textnode",
            "value": "Step 3: Estimate N-Body Forces"
          }
        ]
      },
      {
        "type": "component",
        "name": "p",
        "children": [
          {
            "type": "textnode",
            "value": "Now we are ready to estimate forces!"
          }
        ]
      },
      {
        "type": "component",
        "name": "p",
        "children": [
          {
            "type": "component",
            "name": "link",
            "properties": {
              "class": {
                "type": "value",
                "value": "action"
              },
              "click": {
                "type": "event",
                "value": "theta=0, estimate=true"
              }
            },
            "children": [
              {
                "type": "textnode",
                "value": "To measure forces at a given point, let‚Äôs add a "
              },
              {
                "type": "component",
                "name": "quote",
                "children": [
                  {
                    "type": "textnode",
                    "value": "probe"
                  }
                ]
              },
              {
                "type": "textnode",
                "value": " "
              },
              {
                "type": "component",
                "name": "image",
                "properties": {
                  "alt": {
                    "type": "value",
                    "value": "Probe icon"
                  },
                  "src": {
                    "type": "value",
                    "value": "probe.svg"
                  }
                }
              },
              {
                "type": "textnode",
                "value": " to our diagram"
              }
            ]
          },
          {
            "type": "textnode",
            "value": ".\nThe purple line extending from the probe indicates the direction and magnitude of the total force at that location.\n(To promote visibility, the purple line is three times longer than the actual pixel distance the probe would be moved in a single timestep of the force simulation.)\nThe dotted lines extending to the probe represent the force components exerted by individual points."
          }
        ]
      },
      {
        "type": "component",
        "name": "p",
        "children": [
          {
            "type": "component",
            "name": "em",
            "children": [
              {
                "type": "textnode",
                "value": "Move the probe (click or drag) to explore the force field"
              }
            ]
          },
          {
            "type": "textnode",
            "value": "."
          }
        ]
      },
      {
        "type": "component",
        "name": "p",
        "children": [
          {
            "type": "textnode",
            "value": "Ignoring the quadtree, we can na√Øvely calculate forces by summing the contributions of "
          },
          {
            "type": "component",
            "name": "em",
            "children": [
              {
                "type": "textnode",
                "value": "all"
              }
            ]
          },
          {
            "type": "textnode",
            "value": " individual points.\nOf course, we want to use the quadtree to accelerate calculation and approximate long-range forces.\nRather than compute interactions among individual points, "
          },
          {
            "type": "component",
            "name": "link",
            "properties": {
              "class": {
                "type": "value",
                "value": "action"
              },
              "click": {
                "type": "event",
                "value": "theta=1, estimate=true"
              }
            },
            "children": [
              {
                "type": "textnode",
                "value": "we can compute interactions with centers of mass"
              }
            ]
          },
          {
            "type": "textnode",
            "value": ", using smaller quadtree cells for nearer points and larger cells for more distant points."
          }
        ]
      },
      {
        "type": "component",
        "name": "p",
        "children": [
          {
            "type": "textnode",
            "value": "At this point we skipped a critical detail: what constitutes "
          },
          {
            "type": "component",
            "name": "quote",
            "children": [
              {
                "type": "textnode",
                "value": "long-range"
              }
            ]
          },
          {
            "type": "textnode",
            "value": " versus "
          },
          {
            "type": "component",
            "name": "quote",
            "children": [
              {
                "type": "textnode",
                "value": "short-range"
              }
            ]
          },
          {
            "type": "textnode",
            "value": " forces?\nWe consider both the "
          },
          {
            "type": "component",
            "name": "em",
            "children": [
              {
                "type": "textnode",
                "value": "distance"
              }
            ]
          },
          {
            "type": "textnode",
            "value": " to the center of a quadtree cell and that cell‚Äôs "
          },
          {
            "type": "component",
            "name": "em",
            "children": [
              {
                "type": "textnode",
                "value": "width"
              }
            ]
          },
          {
            "type": "textnode",
            "value": ".\nIf the ratio "
          },
          {
            "type": "component",
            "name": "em",
            "children": [
              {
                "type": "textnode",
                "value": "width / distance"
              }
            ]
          },
          {
            "type": "textnode",
            "value": " falls below a chosen threshold ‚Äì a parameter Œò ("
          },
          {
            "type": "component",
            "name": "em",
            "children": [
              {
                "type": "textnode",
                "value": "theta"
              }
            ]
          },
          {
            "type": "textnode",
            "value": ") ‚Äì we treat the quadtree cell as a source of long-range forces and use its center of mass.\nOtherwise, we will recursively visit the child cells in the quadtree."
          }
        ]
      },
      {
        "type": "component",
        "name": "p",
        "children": [
          {
            "type": "textnode",
            "value": "When Œò = 1, a quadtree cell‚Äôs center of mass will be used ‚Äì and its internal points ignored ‚Äì if the distance from the sample point to the cell‚Äôs center is greater than or equal to the cell‚Äôs width."
          }
        ]
      },
      {
        "type": "component",
        "name": "p",
        "children": [
          {
            "type": "component",
            "name": "em",
            "children": [
              {
                "type": "textnode",
                "value": "Adjust the Œò parameter to view its effect on force estimation"
              }
            ]
          },
          {
            "type": "textnode",
            "value": "."
          }
        ]
      },
      {
        "type": "component",
        "name": "p",
        "children": [
          {
            "type": "textnode",
            "value": "How does the number of considered points change based on the probe location and Œò?\nHow does the direction and magnitude of the total force vary with Œò?"
          }
        ]
      },
      {
        "type": "component",
        "name": "cell-view",
        "properties": {
          "bind-set": {
            "type": "value",
            "value": "theta"
          }
        },
        "children": [
          {
            "type": "textnode",
            "value": "Inputs.range([0, 2], {\n  step: 0.1, label: 'Theta Œò', value: focus < 0 ? -(focus + 1) : focus\n})"
          }
        ]
      },
      {
        "type": "component",
        "name": "p",
        "children": [
          {
            "type": "textnode",
            "value": "We can now perform force estimation for each individual point, using the Barnes-Hut approximation to limit the total number of comparisons!"
          }
        ]
      },
      {
        "type": "component",
        "name": "h1",
        "properties": {
          "id": {
            "type": "value",
            "value": "performance-analysis"
          }
        },
        "children": [
          {
            "type": "textnode",
            "value": "Performance Analysis"
          }
        ]
      },
      {
        "type": "component",
        "name": "p",
        "children": [
          {
            "type": "textnode",
            "value": "To assess the performance of the Barnes-Hut approximation, we can look at\nboth the running time and accuracy of force estimation.\nWe will compare na√Øve ("
          },
          {
            "type": "component",
            "name": "em",
            "children": [
              {
                "type": "textnode",
                "value": "n"
              }
            ]
          },
          {
            "type": "component",
            "name": "sup",
            "children": [
              {
                "type": "textnode",
                "value": "2"
              }
            ]
          },
          {
            "type": "textnode",
            "value": ") calculation to different settings of the Œò parameter."
          }
        ]
      },
      {
        "type": "component",
        "name": "p",
        "children": [
          {
            "type": "textnode",
            "value": "We will take measurements using different point sets, ranging from 500 to 10,000 points.\nFor each point count, we average the results from 50 separate runs of force estimation, each time using a different set of points placed at uniformly random coordinates within a 900 x 500 pixel rectangle."
          }
        ]
      },
      {
        "type": "component",
        "name": "p",
        "children": [
          {
            "type": "component",
            "name": "time-plot",
            "properties": {
              "bind": {
                "type": "value",
                "value": "focus"
              }
            }
          }
        ]
      },
      {
        "type": "component",
        "name": "p",
        "children": [
          {
            "type": "textnode",
            "value": "The running time results confirm that the Barnes-Hut approximation can significantly speed-up computation.\nAs expected, the "
          },
          {
            "type": "component",
            "name": "link",
            "properties": {
              "class": {
                "type": "value",
                "value": "t00 action"
              },
              "click": {
                "type": "event",
                "value": "focus=0"
              }
            },
            "children": [
              {
                "type": "textnode",
                "value": "na√Øve approach"
              }
            ]
          },
          {
            "type": "textnode",
            "value": " exhibits a quadratic relationship, whereas increasing the Œò parameter leads to faster calculations.\nA low setting of "
          },
          {
            "type": "component",
            "name": "link",
            "properties": {
              "class": {
                "type": "value",
                "value": "t05 action"
              },
              "click": {
                "type": "event",
                "value": "focus=0.5"
              }
            },
            "children": [
              {
                "type": "textnode",
                "value": "Œò = 0.5"
              }
            ]
          },
          {
            "type": "textnode",
            "value": " does not fare better than the na√Øve approach until processing about 6,000 points.\nUntil that point, the overhead of quadtree construction and center of mass calculation outstrips any gains in force estimation.\nIn contrast, for "
          },
          {
            "type": "component",
            "name": "link",
            "properties": {
              "class": {
                "type": "value",
                "value": "t10 action"
              },
              "click": {
                "type": "event",
                "value": "focus=1"
              }
            },
            "children": [
              {
                "type": "textnode",
                "value": "Œò = 1"
              }
            ]
          },
          {
            "type": "textnode",
            "value": " and "
          },
          {
            "type": "component",
            "name": "link",
            "properties": {
              "class": {
                "type": "value",
                "value": "t15 action"
              },
              "click": {
                "type": "event",
                "value": "focus=1.5"
              }
            },
            "children": [
              {
                "type": "textnode",
                "value": "Œò = 1.5"
              }
            ]
          },
          {
            "type": "textnode",
            "value": " we see significant improvements in running time."
          }
        ]
      },
      {
        "type": "component",
        "name": "p",
        "children": [
          {
            "type": "textnode",
            "value": "To evaluate approximation error, we measure the average vector distance between the results of the na√Øve scheme and Barnes-Hut.\nIn the context of a force-directed graph layout, this error represents the difference (in pixels) between node positions after applying the na√Øve and approximate methods."
          }
        ]
      },
      {
        "type": "component",
        "name": "p",
        "children": [
          {
            "type": "component",
            "name": "error-plot",
            "properties": {
              "bind": {
                "type": "value",
                "value": "focus"
              }
            }
          }
        ]
      },
      {
        "type": "component",
        "name": "p",
        "children": [
          {
            "type": "textnode",
            "value": "Looking at the error results, we first see that the average error is relatively small: only ~5% of a single pixel in difference!\nHowever, we should take care interpreting these results, as we use the "
          },
          {
            "type": "component",
            "name": "em",
            "children": [
              {
                "type": "textnode",
                "value": "average"
              }
            ]
          },
          {
            "type": "textnode",
            "value": " error per point and the "
          },
          {
            "type": "component",
            "name": "em",
            "children": [
              {
                "type": "textnode",
                "value": "maximum"
              }
            ]
          },
          {
            "type": "textnode",
            "value": " error may be substantially higher.\nWhile "
          },
          {
            "type": "component",
            "name": "link",
            "properties": {
              "class": {
                "type": "value",
                "value": "t10 action"
              },
              "click": {
                "type": "event",
                "value": "focus=1"
              }
            },
            "children": [
              {
                "type": "textnode",
                "value": "Œò = 1"
              }
            ]
          },
          {
            "type": "textnode",
            "value": " and "
          },
          {
            "type": "component",
            "name": "link",
            "properties": {
              "class": {
                "type": "value",
                "value": "t15 action"
              },
              "click": {
                "type": "event",
                "value": "focus=1.5"
              }
            },
            "children": [
              {
                "type": "textnode",
                "value": "Œò = 1.5"
              }
            ]
          },
          {
            "type": "textnode",
            "value": " exhibit similar "
          },
          {
            "type": "component",
            "name": "em",
            "children": [
              {
                "type": "textnode",
                "value": "running times"
              }
            ]
          },
          {
            "type": "textnode",
            "value": ", here we see notably higher "
          },
          {
            "type": "component",
            "name": "em",
            "children": [
              {
                "type": "textnode",
                "value": "error rates"
              }
            ]
          },
          {
            "type": "textnode",
            "value": " for "
          },
          {
            "type": "component",
            "name": "link",
            "properties": {
              "class": {
                "type": "value",
                "value": "t15 action"
              },
              "click": {
                "type": "event",
                "value": "focus=1.5"
              }
            },
            "children": [
              {
                "type": "textnode",
                "value": "Œò = 1.5"
              }
            ]
          },
          {
            "type": "textnode",
            "value": " versus "
          },
          {
            "type": "component",
            "name": "link",
            "properties": {
              "class": {
                "type": "value",
                "value": "t10 action"
              },
              "click": {
                "type": "event",
                "value": "focus=1"
              }
            },
            "children": [
              {
                "type": "textnode",
                "value": "Œò = 1"
              }
            ]
          },
          {
            "type": "textnode",
            "value": " and "
          },
          {
            "type": "component",
            "name": "link",
            "properties": {
              "class": {
                "type": "value",
                "value": "t05 action"
              },
              "click": {
                "type": "event",
                "value": "focus=0.5"
              }
            },
            "children": [
              {
                "type": "textnode",
                "value": "Œò = 0.5"
              }
            ]
          },
          {
            "type": "textnode",
            "value": "."
          }
        ]
      },
      {
        "type": "component",
        "name": "p",
        "children": [
          {
            "type": "textnode",
            "value": "These results suggest that a good default value for Œò ‚Äì with low running time "
          },
          {
            "type": "component",
            "name": "em",
            "children": [
              {
                "type": "textnode",
                "value": "and"
              }
            ]
          },
          {
            "type": "textnode",
            "value": " low approximation error ‚Äì is around 1.0.\nIndeed, in practice it is common to see default settings slightly below 1.\nIn visualization applications, where errors on the order of a few pixels are not a problem, even higher Œò values may be used without issue."
          }
        ]
      },
      {
        "type": "component",
        "name": "h1",
        "properties": {
          "id": {
            "type": "value",
            "value": "conclusion"
          }
        },
        "children": [
          {
            "type": "textnode",
            "value": "Conclusion"
          }
        ]
      },
      {
        "type": "component",
        "name": "p",
        "children": [
          {
            "type": "textnode",
            "value": "The Barnes-Hut approximation has had a major impact on both physical simulation and network visualization, enabling n-body calculations to scale to much larger data sets than na√Øve force calculation permits."
          }
        ]
      },
      {
        "type": "component",
        "name": "p",
        "children": [
          {
            "type": "component",
            "name": "link",
            "properties": {
              "class": {
                "type": "value",
                "value": "action"
              },
              "click": {
                "type": "event",
                "value": "step=77, estimate=false, layout=true"
              }
            },
            "children": [
              {
                "type": "textnode",
                "value": "Returning to our initial network diagram"
              }
            ]
          },
          {
            "type": "textnode",
            "value": ", we can use Barnes-Hut to efficiently compute repulsive forces at each timestep.\nFor each animation frame, we perform the approximation anew, creating a new quadtree, accumulating centers of mass, and (approximately) estimating forces."
          }
        ]
      }
    ]
  }
}