<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0"/>
    <meta charset="utf-8" />
    <title>An Iterative Image Registration Technique with an Application to Stereo Vision</title>
    <meta property="og:title" content="An Iterative Image Registration Technique with an Application to Stereo Vision" />
    <meta property="og:type" content="article" />
    <meta property="og:description" content="An Iterative Image Registration Technique with an Application to Stereo Vision" />
    <meta property="description" content="An Iterative Image Registration Technique with an Application to Stereo Vision" />
    <style>
article{--section-prefix:"§";--equation-prefix:"Equation ";--figure-prefix:"Figure ";--table-prefix:"Table ";--double-quote-start:"“";--double-quote-end:"”";--single-quote-start:"‘";--single-quote-end:"’";--highlight-color:#ff0;--tiny-size:0.5em;--script-size:0.7em;--smaller-size:0.8em;--small-size:0.9em;--large-size:1.2em;--larger-size:1.4em;--huge-size:1.8em;--inline-math-size:1em;--ref-color:steelblue;--ref-color-light:#c8dae9;--ref-color-hover:#90b4d2;--ref-color-error:maroon;--ref-weight:500;--ref-decoration:none;width:var(--article-width);margin-left:var(--article-margin-left);padding:var(--article-padding);--inline-math-size:1.14em}a{color:var(--ref-color);font-weight:var(--ref-weight);text-decoration:var(--ref-decoration)}a:hover{color:var(--ref-color-hover)}sub,sup{line-height:0}q{quotes:var(--double-quote-start) var(--double-quote-end)}q.single{quotes:var(--single-quote-start) var(--single-quote-end)}blockquote{margin-left:2em}.action{cursor:pointer;text-decoration:underline dashed 1px #444}.tooltip{display:none;background-color:#fff;z-index:1;position:absolute;filter:drop-shadow(3px 3px 3px rgba(0,0,0,.2));border:1px solid #ccc;padding:.5em;cursor:auto;text-indent:initial;text-align:initial}header h1{font-size:var(--huge-size)}header .author-org{font-style:italic}header .author-org::before{content:" · "}h1{font-size:1.4rem}h2{font-size:1.2rem}h3{font-size:1.1rem}h4,h5,h6{font-size:1rem}h1[data-counter]::before,h2[data-counter]::before,h3[data-counter]::before{content:attr(data-counter) " "}figure.figure>figcaption[data-counter]::before,figure.teaser>figcaption[data-counter]::before{content:var(--figure-prefix) attr(data-counter) ". "}figure.table>figcaption[data-counter]::before{content:var(--table-prefix) attr(data-counter) ". "}table{border-spacing:0;border-collapse:collapse}thead tr{border-bottom:1px solid #ccc}tbody td,thead th{font-size:var(--small-size);padding:1px .33em;text-align:left;font-variant-numeric:tabular-nums}tbody tr{border-bottom:1px solid #eee}ol.references{padding-inline-start:2em}ol.references li{font-size:var(--small-size);margin-bottom:6px}:root{--max-article-width:85ex;--article-padding:32px;--margin-width:400px;--gap-width:100px;--article-width:min(var(--max-article-width), calc(100vw - var(--article-padding) * 2 - var(--gap-width) - var(--margin-width)));--article-margin-left:max(0px, calc(((100vw - var(--article-width) - var(--gap-width) - var(--margin-width)) / 2)))}html{box-sizing:border-box}*,:after,:before{box-sizing:inherit;margin:0;padding:0}h1,h2,h3{padding:0}h1{padding-top:.5em}.title{font-size:24pt;font-weight:700}ol,p,pre,table,ul{margin:0}ol,ul{padding-left:1.5em}section>p{margin-bottom:16px}section>p:last-child{margin-bottom:0}.margin,aside{position:relative;float:right;clear:right;width:var(--margin-width);margin-right:calc(-1 * var(--gap-width) - var(--margin-width));margin-bottom:1em;vertical-align:unset}aside{margin-left:0;margin-top:0}aside>:first-child{margin-top:0}aside>:last-child{margin-bottom:0}.inlinenote-number{line-height:1;padding:1px}.float-left{float:left;margin-right:1em}.float-right{float:right;margin-left:1em}.sticky{position:sticky;top:0;z-index:10}.page{text-align:justify;width:calc(90vw - 2 * var(--article-padding) - 2 * var(--article-margin-left))}figure,pre{max-width:calc(100vw - 2 * var(--article-padding) - 2 * var(--article-margin-left));overflow-x:auto}.full{max-width:100vw}.full-image{width:100%;object-fit:cover;vertical-align:middle}.full figcaption{background:#eee;padding:16px 0}.centered{text-align:center}figure{margin:0;padding:5px 0}aside canvas,aside img,aside svg,figure canvas,figure img,figure svg{object-fit:contain;max-width:100%;height:auto}header{padding-bottom:1em}footer{padding:2em 0}@media (max-width:1100px){:root{--article-padding:16px}article{width:min(var(--max-article-width),calc(100% - var(--article-padding) * 2))}figure,pre{max-width:calc(100vw - var(--article-padding) * 2)}.page{width:min(var(--max-article-width),100%)}.margin,aside{float:none;margin:0;width:auto}.inline-note-number{cursor:pointer;padding:1px 4px}.inline-note .note::before,.inline-note:not(.open) .note{display:none}}@media print{.sticky{position:relative}}.cite-ref{color:var(--ref-color);font-weight:var(--ref-weight);text-decoration:var(--ref-decoration);cursor:pointer}.cite-ref:hover{color:var(--ref-color-hover)}.cite-ref.unresolved,.cite-ref.unresolved:hover{color:var(--ref-color-error)}.cite-ref .tooltip{width:400px;font-weight:400;color:#000}.cite-ref.unresolved .tooltip{text-align:center;padding:4px;width:auto}.cite-author,.cite-venue{margin-top:.25em}.cite-author-button{padding:4px;background-color:#eee;border-radius:6px;font-size:.9em;cursor:pointer}.cite-author-hidden{display:none}.cite-author,.cite-venue,.cite-year{color:#666}.cite-title a{font-weight:700}.cite-venue{font-style:italic}.cite-detail{border-top:1px solid #ccc;padding-top:.5em;margin-top:.5em}.cross-ref{color:var(--ref-color);font-weight:var(--ref-weight);text-decoration:var(--ref-decoration);cursor:pointer}.cross-ref:hover{color:var(--ref-color-hover)}.cross-ref.unresolved,.cross-ref.unresolved:hover{color:var(--ref-color-error)}.cross-ref.sec.full::before{content:var(--section-prefix)}.cross-ref.fig.full::before{content:var(--figure-prefix)}.cross-ref.tbl.full::before{content:var(--table-prefix)}.cross-ref.eqn.full::before{content:var(--equation-prefix)}.cross-ref-tooltip{color:#000}.cross-ref-tooltip figure{width:400px;padding-bottom:0}.cross-ref-tooltip figcaption{background-color:#fff;padding-bottom:0}:not(.katex-display)>.katex{font-size:var(--inline-math-size)!important}.katex *{pointer-events:none}.katex .enclosing,.katex .enclosing *,.katex .maug-parent{pointer-events:initial}.katex .maug{display:inline-block;cursor:pointer}.katex .maug:hover{background:rgba(103,176,202,.22)}.katex .maug-tooltip{z-index:99;position:absolute;border-bottom:2px solid #000;background:#fff;border-radius:2px;padding:1px 5px;filter:drop-shadow(1px 1px 2px rgba(0, 0, 0, .2));font-size:.85em;pointer-events:none!important}.katex .maug-tooltip svg{display:inline-block;position:absolute}.katex .maug-tooltip *{pointer-events:none!important}body{font:16px/1.5 -apple-system,system-ui,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";background:#fff;color:#000}:not(pre)>code,pre{font-family:monospace;font-size:15px}h1,h2,h3,h4,h5,h6{font-weight:600;line-height:1.25em;margin:24px 0 16px}h1,h2{border-bottom:1px solid rgba(0,0,0,.1);padding-bottom:6px;width:fit-content}.katex-display,article p,article>code-block>pre,article>ol,article>pre,article>table,article>ul{margin:12px 0}td,th{border-bottom:1px solid rgba(0,0,0,.2);transition:.1s ease-out}th,tr:hover td{background:rgba(0,0,0,.1)}figure>figcaption{font-weight:600;font-size:var(--small-size);line-height:1.4em;padding-bottom:1ex}.sticky{background:rgba(255,255,255,.8);backdrop-filter:blur(4px)}.note,aside{font-style:inherit;font-size:var(--small-size)}.note{background:#fff;transition:.1s ease-out}.inline-note:hover .inline-note-number,.inline-note:hover .note{background:var(--ref-color-light)}.inline-note .note::before{font-size:var(--smaller-size)}.normal{font-weight:400}.demi{font-weight:600}.bold,.strong{font-weight:700}.code,.mono{font-family:monospace}.em,.emph,.italic{font-style:italic}.highlight{background-color:var(--highlight-color)}.strike{text-decoration:line-through}.underline{text-decoration:underline}.smallcaps{font-variant:small-caps}.lowercase{text-transform:lowercase}.uppercase{text-transform:uppercase}.capitalize{text-transform:capitalize}.left{text-align:left}.right{text-align:right}.center{text-align:center}.justify{text-align:justify}.tiny{font-size:var(--tiny-size)}.scriptsize{font-size:var(--script-size)}.footnotesize,.smaller{font-size:var(--smaller-size)}.small{font-size:var(--small-size)}.large{font-size:var(--large-size)}.larger{font-size:var(--larger-size)}.huge{font-size:var(--huge-size)}.hide{display:none}:root{--gap-width:50px;--margin-width:500px}.sticky:has(#fig2){top:32px}.figures-aside{max-height:calc(100vh - 2 * var(--article-padding));overflow-y:auto;padding-right:12px}
    </style>
  </head>
  <body>
    <article><header><h1 role="banner">An Iterative Image Registration Technique with an Application to Stereo Vision</h1><div class="author"><span class="author-name">Bruce D. Lucas</span><span class="author-org">Carnegie-Mellon University</span></div><div class="author"><span class="author-name">Takeo Kanade</span><span class="author-org">Carnegie-Mellon University</span></div></header><aside><p>Today, this 1981 paper is known for introducing the
<a href="https://en.wikipedia.org/wiki/Lucas%E2%80%93Kanade_method">Lucas–Kanade method</a> for optical flow estimation.</p><p><a href="https://courses.cs.duke.edu/spring19/compsci527/papers/Lucas.pdf">Original paper (PDF)</a></p></aside><h1 nonumber="true">Abstract</h1><p>Image registration finds a variety of applications in computer vision. Unfortunately, traditional image registration techniques tend to be costly. We present a new image registration technique that makes use of the spatial intensity gradient of the images to find a good match using a type of Newton-Raphson iteration. Our technique is faster because it examines far fewer potential matches between the images than existing techniques. Furthermore, this registration technique can be generalized to handle rotation, scaling and shearing. We show show our technique can be adapted for use in a stereo vision system.</p><h1 id="sec1" data-counter="1">Introduction</h1><p>Image registration finds a variety of applications in computer vision, such as image matching for stereo vision, pattern recognition, and motion analysis. Untortunately, existing techniques for image registration tend to be costly. Moreover, they generally fail to deal with rotation or other distortions of the images.</p><p>In this paper we present a new image registration technique that uses spatial intensity gradient information to direct the search for the position that yields the best match. By taking more information about the images into account, this technique is able to find the best match between two images with far fewer comparisons of images than techniques which examine the possible positions of registration in some fixed order. Our technique takes advantage of the fact that in many applications the two images are already in approximate registration. This technique can be generalized to deal with arbitrary linear distortions of the image, including rotation. We then describe a stereo vision system that uses this registration technique, and suggest some further avenues for research toward making effective use of this method in stereo image understanding.</p><h1 id="sec2" data-counter="2">The registration problem</h1><figure id="fig1" class="figure margin" data-counter="1"><img src="assets/fig1.svg"></img><figcaption data-counter="1">The image registration problem.</figcaption></figure><p>The translational image registration problem can be characterized as follows: We are given functions <tex-math mode="inline" code="F(x)" maug="@F(@x)"></tex-math> and <tex-math mode="inline" code="G(x)" maug="@G(@x)"></tex-math> which give the respective pixel values at each location <tex-math mode="inline" code="x" maug="@x"></tex-math> in two images, where <tex-math mode="inline" code="x" maug="@x"></tex-math> is a vector. We wish to find the disparity vector <tex-math mode="inline" code="h" maug="@h"></tex-math> which minimizes some measure of the difference between <tex-math mode="inline" code="F(x + h)" maug="@F(@x + @h)"></tex-math> and <tex-math mode="inline" code="G(x)" maug="@G(@x)"></tex-math>, for <tex-math mode="inline" code="x" maug="@x"></tex-math> in some region of interest <tex-math mode="inline" code="R" maug="@R"></tex-math>. (See <cross-ref type="fig" xref="fig1" index="1"></cross-ref>).</p><p>Typical measures of the difference between <tex-math mode="inline" code="F(x + h)" maug="@F(x + @h)"></tex-math> and <tex-math mode="inline" code="G(x)" maug="@G(x)"></tex-math> are:</p><ul><li><p><tex-math mode="inline" code="L_1 \, \text{norm} = \sum_{x \varepsilon R} | F(x + h) - G(x) |" maug="L_1 \, \text{norm} = \sum_{x \varepsilon @R} | @F(x + @h) - @G(x) |"></tex-math></p></li><li><p><tex-math mode="inline" code="L_2 \, \text{norm} = (\sum_{x \varepsilon R} [ F(x + h) - G(x) ]^2)^{\frac{1}{2}}" maug="L_2 \, \text{norm} = (\sum_{x \varepsilon @R} [ @F(x + @h) - @G(x) ]^2)^{\frac{1}{2}}"></tex-math></p></li><li><p>negative of normalized correlation</p></li></ul><tex-math maug="= \frac{-\sum_{x \varepsilon @R} @F(x + @h) @G(x)}{(\sum_{x \varepsilon @R})^\frac{1}{2} (\sum_{x \varepsilon @R} @G(x) ^2)^ \frac{1}{2}}">= \frac{-\sum_{x \varepsilon R} F(x + h) G(x)}{(\sum_{x \varepsilon R})^\frac{1}{2} (\sum_{x \varepsilon R} G(x) ^2)^ \frac{1}{2}}</tex-math><p>We will propose a more general measure of image difference, of which both the <tex-math mode="inline" code="L_2"></tex-math> norm and the correlation are special cases. The <tex-math mode="inline" code="L_1"></tex-math> norm is chiefly of interest as an inexpensive approximation to the <tex-math mode="inline" code="L_2"></tex-math> norm.</p><h1 id="sec3" data-counter="3">Existing techniques</h1><p>An obvious technique for registering two images is to calculate a measure of the difference between the images at all possible values of the disparity vector <tex-math mode="inline" code="h" maug="@h"></tex-math>—that is, to exhaustively search the space of possible values of <tex-math mode="inline" code="h" maug="@h"></tex-math>. This technique is very time consuming: if the size of the picture <tex-math mode="inline" code="G(x)" maug="@G(x)"></tex-math> is <tex-math mode="inline" code="N \times N" maug="@N \times @N"></tex-math>, and the region of possible values of <tex-math mode="inline" code="h" maug="@h"></tex-math> is of size <tex-math mode="inline" code="M \times M" maug="@M \times @M"></tex-math>, then this method requires <tex-math mode="inline" code="O(M^2 N^2)" maug="O(@M^2 @N^2)"></tex-math> time to compute.</p><p>Speedup at the risk of possible failure to find the best <tex-math mode="inline" code="h" maug="@h"></tex-math> can be achieved by using a hill-climbing technique. This technique begins with an initial estimate <tex-math mode="inline" code="h_0" maug="@h_0"></tex-math> of the disparity. To obtain the next guess from the current guess <tex-math mode="inline" code="h_k" maug="@h_k"></tex-math>, one evaluates the difference function at all points in a small (say, <tex-math mode="inline" code="3 \times 3"></tex-math>) neighborhood of <tex-math mode="inline" code="h_k"></tex-math> and takes as the next guess <tex-math mode="inline" code="h_{k+1}" maug="@h_{k+1}"></tex-math> that point which minimizes the difference function. As with all hill-climbing techniques, this method suffers from the problem of false peaks: the local optimum that one attains may not be the global optimum. This technique operates in <tex-math mode="inline" code="O(M^2 N)" maug="O(@M^2 @N)"></tex-math> time on the average, for <tex-math mode="inline" code="M" maug="@M"></tex-math> and <tex-math mode="inline" code="N" maug="@N"></tex-math> as above.</p><p>Another technique, known as the sequential similarity detection algorithm (SSDA) <span class="cite-list">[<cite-ref key="Barnea1972" index="2"></cite-ref>]</span>, only estimates the error for each disparity vector <tex-math mode="inline" code="h" maug="@h"></tex-math>. In SSDA, the error function must be a cumulative one such as the <tex-math mode="inline" code="L_1"></tex-math> or <tex-math mode="inline" code="L_2"></tex-math> norm. One stops accumulating the error for the current <tex-math mode="inline" code="h" maug="@h"></tex-math> under investigation when it becomes apparent that the current <tex-math mode="inline" code="h" maug="@h"></tex-math> is not likely to give the best match. Criteria for stopping include a fixed threshold such that when the accumulated error exceeds this threshold one goes on to the next <tex-math mode="inline" code="h" maug="@h"></tex-math>, and a variable threshold which increases with the number of pixels in <tex-math mode="inline" code="R" maug="@R"></tex-math> whose contribution to the total error have been added. SSDA leaves unspecified the order in which the <tex-math mode="inline" code="h"></tex-math>’s are examined.</p><p>Note that in SSDA if we adopt as our threshold the minimum error we have found among the <tex-math mode="inline" code="h" maug="@h"></tex-math> examined so far, we obtain an algorithm similar to alpha-beta pruning in minmax game trees <span class="cite-list">[<cite-ref key="Nilsson1971" index="7"></cite-ref>]</span>. Here we take advantage of the fact that in evaluating <tex-math mode="inline" code="\min_{h} \sum_x d(x, h)" maug="\min_{@h} \sum_x d(x, @h)"></tex-math>, where <tex-math mode="inline" code="d(x, h)" maug="d(x, @h)"></tex-math> is the contribution of pixel <tex-math mode="inline" code="x" maug="@x"></tex-math> at disparity <tex-math mode="inline" code="h" maug="@h"></tex-math> to the total error, the <tex-math mode="inline" code="\sum_x"></tex-math> can only increase as we look at more <tex-math mode="inline" code="x"></tex-math>’s (more pixels).</p><p>Some registration algorithms employ a coarse-fine search strategy. See <span class="cite-list">[<cite-ref key="Moravec1979" index="6"></cite-ref>]</span> for an example. One of the techniques discussed above is used to find the best registration for the images at low resolution, and the low resolution match is then used to constrain the region of possible matches examined at higher resolution. The coarse-fine strategy is adopted implicitly by some image understanding systems which work with a <q>pyramid</q> of images of the same scene at various resolutions.</p><p>It should be nated that some of the techniques mentioned so far can be combined because they concern orthogonal aspects of the image registration problem. Hill climbing and exhaustive search concern only the order in which the algorithm searches for the best match, and SSDA specifies only the method used to calculate (an estimate of) the difference function. Thus for example, one could use the SSDA technique with either hill climbing or exhaustive search, in addition a coarse-fine strategy may be adopted.</p><p>The algorithm we present specifies the order in which to search the space of possible <tex-math mode="inline" code="h" maug="@h"></tex-math>’s. In particular, our technique starts with an initial estimate of <tex-math mode="inline" code="h" maug="@h"></tex-math>, and it uses the spatial intensity gradient at each point of the image to modify the current estimate of <tex-math mode="inline" code="h" maug="@h"></tex-math> to obtain an <tex-math mode="inline" code="h" maug="@h"></tex-math> which yields a better match. This process is repeated in a kind of Newton-Raphson iteration. If the iteration converses, it will do so in <tex-math mode="inline" code="O(M^2 \log N)" maug="O(@M^2 \log @N)"></tex-math> steps on the average. This registration technique can be combined with a coarse-fine strategy,since is requires an initial estimate of the approximate disparity <tex-math mode="inline" code="h" maug="@h"></tex-math>.</p><h1 id="sec4" data-counter="4">The registration algorithm</h1><p>In this section we first derive an intuitive solution to the one dimensional registration problem, and then we derive an alternative solution which we generalize to multiple dimensions. We then show how our technique generalizes to other kinds of registration. We also discuss implementation and performance of the algorithm.</p><h2 id="sec4_1" data-counter="4.1">One dimensional case</h2><div class="sticky margin" sticky-until="#sec4_2"><figure id="fig2" class="figure" data-counter="2"><img src="assets/fig2.svg"></img><figcaption data-counter="2">Two curves to be matched.</figcaption></figure></div><p>In the one-dimensional registration problem, we wish to find the horizontal disparity <tex-math mode="inline" code="h" maug="@h"></tex-math> between two curves <tex-math mode="inline" code="F(x)" maug="@F(x)"></tex-math> and <tex-math mode="inline" code="G(x) = F(x + h)" maug="@G(x) = @F(x + @h)"></tex-math>. This is illustrated in <cross-ref type="fig" xref="fig2" index="2"></cross-ref>.</p><p>Our solution to this problem depends on <tex-math mode="inline" code="F&#39;(x)" maug="@F&#39;(x)"></tex-math>, a linear approximation to the behavior of <tex-math mode="inline" code="F(x)" maug="@F(x)"></tex-math> in the neighborhood of <tex-math mode="inline" code="x" maug="@x"></tex-math>, as do all subsequent solutions in this paper. In particular, for small <tex-math mode="inline" code="h" maug="@h"></tex-math>,</p><tex-equation id="e1" type="equation" maug="\begin{split}
  @F&#39;(x) &amp;\approx \frac{@F(x + @h) - @F(x)}{@h} \\
  &amp;= \frac{@G(x) - @F(x)}{@h}
\end{split}" data-counter="1">\begin{split}
  F&#39;(x) &amp;\approx \frac{F(x + h) - F(x)}{h} \\
  &amp;= \frac{G(x) - F(x)}{h}
\end{split}</tex-equation><p>so that</p><tex-equation id="e2" maug="@h = \frac{@G(x) - @F(x)}{@F&#39;(x)}" data-counter="2">h = \frac{G(x) - F(x)}{F&#39;(x)}</tex-equation><p>The success of our algorithm requires <tex-math mode="inline" code="h" maug="@h"></tex-math> to be small enough that this approximation is adequate. In section <cross-ref type="sec" xref="sec4_3" index="4.3"></cross-ref> we will show how to extend the range of <tex-math mode="inline" code="h" maug="@h"></tex-math>’s over which this approximation is adequate by smoothing the images.</p><p>The approximation to <tex-math mode="inline" code="h" maug="@h"></tex-math> given in <cross-ref type="eqn" xref="e2" index="2"></cross-ref> depends on <tex-math mode="inline" code="x" maug="@x"></tex-math>. A natural method for combining the various estimates of <tex-math mode="inline" code="h" maug="@h"></tex-math> at various values of <tex-math mode="inline" code="x" maug="@x"></tex-math> would be to simply average them:</p><tex-equation id="e3" maug="@h \approx \sum_x \frac{@G(x) - @F(x)}{@F&#39;(x)} / \sum_x 1" data-counter="3">h \approx \sum_x \frac{G(x) - F(x)}{F&#39;(x)} / \sum_x 1</tex-equation><p>We can improve this average by realizing that the linear approximation in <cross-ref type="eqn" xref="e1" index="1"></cross-ref> is good where <tex-math mode="inline" code="F(x)" maug="@F(x)"></tex-math> is nearly linear, and conversely is worse where <tex-math mode="inline" code="|F&#39;&#39;(x)|" maug="|@F&#39;&#39;(x)|"></tex-math> is large. Thus we could weight the contribution of each term to the average in <cross-ref type="eqn" xref="e3" index="3"></cross-ref> in inverse proportion to an estimate of <tex-math mode="inline" code="|F&#39;&#39;(x)|" maug="|@F&#39;&#39;(x)|"></tex-math>. One such estimate is</p><tex-equation id="e4" maug="@F&#39;&#39;(x) \approx \frac{@G&#39;(x) - @F&#39;(x)}{@h}" data-counter="4">F&#39;&#39;(x) \approx \frac{G&#39;(x) - F&#39;(x)}{h}</tex-equation><p>Since our estimate is to be used as a weight in an average, we can drop the constant factor of <tex-math mode="inline" code="\frac{1}{h}" maug="\frac{1}{@h}"></tex-math> in <cross-ref type="eqn" xref="e4" index="4"></cross-ref>, and use as our weighting function</p><tex-equation id="e5" maug="@w(x) = \frac{1}{|@G&#39;(x) - @F(x)|}" data-counter="5">w(x) = \frac{1}{|G&#39;(x) - F(x)|}</tex-equation><p>This in fact appeals to our intuition: for example, in <cross-ref type="fig" xref="fig2" index="2"></cross-ref>, where the two curves cross, the estimate of <tex-math mode="inline" code="h" maug="@h"></tex-math> provided by <cross-ref type="eqn" xref="e2" index="2"></cross-ref> is <tex-math mode="inline" code="0"></tex-math>, which is bad; fortunately, the weight given to this estimate in the average is small, since the difference between <tex-math mode="inline" code="F&#39;(x)" maug="@F&#39;(x)"></tex-math> and <tex-math mode="inline" code="G&#39;(x)" maug="@G&#39;(x)"></tex-math> at this point is large. The average with weighting is</p><tex-equation id="e6" maug="@h \approx \sum_x \frac{@w(x)[@G(x) - @F(x)]}{@F&#39;(x)} / \sum_{x} @w(x)" data-counter="6">h \approx \sum_x \frac{w(x)[G(x) - F(x)]}{F&#39;(x)} / \sum_{x} w(x)</tex-equation><p>where <tex-math mode="inline" code="w(x)" maug="@w(x)"></tex-math> is given by <cross-ref type="eqn" xref="e5" index="5"></cross-ref>.</p><p>Having obtained this estimate. we can then move <tex-math mode="inline" code="F(x)" maug="@F(x)"></tex-math> by our estimate of <tex-math mode="inline" code="h" maug="@h"></tex-math>, and repeat this procedure, yielding a type of Newton-Raphson iteration. Ideally, our sequence of estimates of <tex-math mode="inline" code="h" maug="@h"></tex-math> will converge to the best <tex-math mode="inline" code="h" maug="@h"></tex-math>. This iteration is expressed by</p><tex-math maug="@h_0 = 0,">h_0 = 0,</tex-math><tex-equation id="e7" maug="@h_{k+1} = @h_k + \sum_{x} \frac{@w(x)[@G(x) - @F(x + @h_k)]}{@F&#39;(x + @h_k)} / \sum_x @w(x)" data-counter="7">h_{k+1} = h_k + \sum_{x} \frac{w(x)[G(x) - F(x + h_k)]}{F&#39;(x + h_k)} / \sum_x w(x)</tex-equation><h2 id="sec4_2" data-counter="4.2">An alternative derivation</h2><p>The derivation given above does not generalize well to two dimensions because the two-dimensional linear approximation occurs in a different form. Moreover, <cross-ref type="eqn" xref="e2" index="2"></cross-ref> is undefined where <tex-math mode="inline" code="F&#39;(x) = 0" maug="@F&#39;(x) = 0"></tex-math>, i.e. where the curve is level. Both of these problems can be corrected by using the linear approximation of equation <cross-ref type="eqn" xref="e1" index="1"></cross-ref> in the form</p><tex-equation id="e8" maug="@F(x + @h) \approx @F(x) + @h @F&#39;(x)" data-counter="8">F(x + h) \approx F(x) + h F&#39;(x)</tex-equation><p>to find the <tex-math mode="inline" code="h" maug="@h"></tex-math> which minimizes the <tex-math mode="inline" code="L_2"></tex-math> norm measure of the difference between the curves:</p><tex-math maug="@E = \sum_x [@F(x + @h) - @G(x)]^2">E = \sum_x [F(x + h) - G(x)]^2</tex-math><p>To minimize the error with respect to <tex-math mode="inline" code="h" maug="@h"></tex-math>, we set</p><tex-equation maug="\begin{split}
  0 &amp;= \frac{\partial @E}{\partial @h} \\
  &amp;\approx \frac{\partial}{\partial @h} \sum_x [@F(x) + @h @F&#39;(x) - @G(x)]^2 \\
  &amp;= \sum_x 2 @F&#39;(x)[@F(x) + @h@F&#39;(x) - @G(x)]
\end{split}" data-counter="9">\begin{split}
  0 &amp;= \frac{\partial E}{\partial h} \\
  &amp;\approx \frac{\partial}{\partial h} \sum_x [F(x) + h F&#39;(x) - G(x)]^2 \\
  &amp;= \sum_x 2 F&#39;(x)[F(x) + hF&#39;(x) - G(x)]
\end{split}</tex-equation><p>from which</p><tex-equation id="e9" maug="@h \approx \frac{\sum_x @F&#39;(x)[@G(x) - @F(x)]}{\sum_x @F&#39;(x)^2}" data-counter="10">h \approx \frac{\sum_x F&#39;(x)[G(x) - F(x)]}{\sum_x F&#39;(x)^2}</tex-equation><p>This is essentially the same solution that we derived in <cross-ref type="eqn" xref="e6" index="6"></cross-ref>, but with the weighting function <tex-math mode="inline" code="w(x) = F&#39;(x)^2" maug="@w(x) = @F&#39;(x)^2"></tex-math>. As we will see the form of the linear approximation we have used here generalizes to two or more dimensions. Moreover, we have avoided the problem of dividing by <tex-math mode="inline" code="0"></tex-math>, since in <cross-ref type="eqn" xref="e9" index="10"></cross-ref> we will divide by <tex-math mode="inline" code="0"></tex-math> only if <tex-math mode="inline" code="F&#39;(x) = 0" maug="@F&#39;(x) = 0"></tex-math> everywhere (in which case <tex-math mode="inline" code="h" maug="@h"></tex-math> really is undefined), whereas in <cross-ref type="eqn" xref="e3" index="3"></cross-ref> we will divide by <tex-math mode="inline" code="0"></tex-math> if <tex-math mode="inline" code="F&#39;(x) = 0" maug="@F&#39;(x) = 0"></tex-math> anywhere.</p><p>The iterative form with weighting corresponding to <cross-ref type="eqn" xref="e7" index="7"></cross-ref> is</p><tex-math maug="@h_0 = 0,">h_0 = 0,</tex-math><tex-equation id="e10" maug="@h_{k+1} = @h_k + \frac{\sum_x @w(x) @F&#39;(x + @h_k) [@G(x) - @F(x + @h_k)]}{\sum_x @w(x) @F&#39;(x + @h_k)^2}" data-counter="11">h_{k+1} = h_k + \frac{\sum_x w(x) F&#39;(x + h_k) [G(x) - F(x + h_k)]}{\sum_x w(x) F&#39;(x + h_k)^2}</tex-equation><p>where <tex-math mode="inline" code="w(x)" maug="@w(x)"></tex-math> is given by <cross-ref type="eqn" xref="e5" index="5"></cross-ref>.</p><h2 id="sec4_3" data-counter="4.3">Performance</h2><p>A natural question to ask is under what conditions and how fast the sequence of <tex-math mode="inline" code="h_k" maug="@h_k"></tex-math>’s converges to the real <tex-math mode="inline" code="h"></tex-math>. Consider the case:</p><p><tex-math mode="inline" code="F(x) = \sin{x}" maug="@F(x) = \sin{x}"></tex-math>,</p><p><tex-math mode="inline" code="G(x) = F(x + h) = \sin{(x + h)}" maug="@G(x) = @F(x + @h) = \sin{(x + @h)}"></tex-math>.</p><p>It can be shown that both versions of the registration algorithm given above will converge to the correct <tex-math mode="inline" code="h" maug="@h"></tex-math> for <tex-math mode="inline" code="|h| &lt; \pi" maug="|@h| &lt; \pi"></tex-math>, that is, for initial misregistrations as large as one-half wavelength. This suggests that we can improve the range of convergence of the algorithm by suppressing high spatial frequencies in the image, which can be accomplished by smoothing the image, i.e. by replacing each pixel of the image by a weighted average of neighboring pixels. The tradeoff is that smoothing suppresses small details, and thus makes the match less accurate. If the smoothing window is much larger than the size of the object that we are trying to match, the object may be suppressed entirely, and so no match will be possible.</p><p>Since lowpass filtered images can be sampled at lower resolution with no loss of information, the above observation suggests that we adopt a coarse-fine strategy. We can use a low resolution smoothed version of the image to obtain an approximate match. Applying the algorithm to higher resolution images will refine the match obtained at lower resolution.</p><p>While the effect of smoothing is to extend the range of convergence, the weighting function serves to improve the accuracy of the approximation, and thus to speed up the convergence. Without weighting, i.e. with <tex-math mode="inline" code="w(x) = 1" maug="@w(x) = 1"></tex-math>, the calculated disparity <tex-math mode="inline" code="h_1" maug="@h_1"></tex-math> of the first iteration of <cross-ref type="eqn" xref="e10" index="11"></cross-ref> with <tex-math mode="inline" code="F(x) = \sin{x}" maug="@F(x) = \sin{x}"></tex-math> falls off to zero as the disparity approaches one-half wavelength. However, with <tex-math mode="inline" code="w(x)" maug="@w(x)"></tex-math> as in <cross-ref type="eqn" xref="e5" index="5"></cross-ref>, the calculation of disparity is much more accurate, and only falls off to zero at a disparity very near one-half wavelength. Thus with <tex-math mode="inline" code="w(x)" maug="@w(x)"></tex-math> as in <cross-ref type="eqn" xref="e5" index="5"></cross-ref> convergence is faster for large disparities.</p><h2 id="sec4_4" data-counter="4.4">Implementation</h2><p>Implementing <cross-ref type="eqn" xref="e10" index="11"></cross-ref> requires calculating the weighted sums of the quantities <tex-math mode="inline" code="F&#39; G" maug="@F&#39; @G"></tex-math>, <tex-math mode="inline" code="F&#39; F" maug="@F&#39; @F"></tex-math>, and <tex-math mode="inline" code="(F&#39;)^2" maug="(@F&#39;)^2"></tex-math> over the region of interest <tex-math mode="inline" code="R" maug="@R"></tex-math>. We cannot calculate <tex-math mode="inline" code="F&#39;(x)" maug="@F&#39;(x)"></tex-math> exactly, but for the purposes of this algorithm, we can estimate it by</p><tex-math maug="@F&#39;(x) \approx \frac{@F(x + \Delta x) - @F(x)}{\Delta x}">F&#39;(x) \approx \frac{F(x + \Delta x) - F(x)}{\Delta x}</tex-math><p>and similarly for <tex-math mode="inline" code="G&#39;(x)" maug="@G&#39;(x)"></tex-math>, where we choose <tex-math mode="inline" code="\Delta x"></tex-math> appropriately small (e.g. one pixel). Some more sophisticated technique could be used for estimating the first derivatives, but in general such techniques are equivalent to first smoothing the function, which we have proposed doing for other reasons, and then taking the difference.</p><h2 id="sec4_5" data-counter="4.5">Generalization to multiple dimensions</h2><p>The one-dimensional registration algorithm given above can be generalized to two or more dimensions. We wish to minimize the <tex-math mode="inline" code="L_2"></tex-math> norm measure of error:</p><tex-math maug="@E = \sum_{x \varepsilon @R} [@F(x + @h) - @G(x)]^2">E = \sum_{x \varepsilon R} [F(x + h) - G(x)]^2</tex-math><p>where <tex-math mode="inline" code="x" maug="@x"></tex-math> and <tex-math mode="inline" code="h" maug="@h"></tex-math> are <tex-math mode="inline" code="n"></tex-math>-dimensional row vectors. We make a linear approximation analogous to that in <cross-ref type="eqn" xref="e8" index="8"></cross-ref>,</p><tex-math maug="@F(x + @h) \approx @F(x) + @h \frac{\partial}{\partial x} @F(x)">F(x + h) \approx F(x) + h \frac{\partial}{\partial x} F(x)</tex-math><p>where <tex-math mode="inline" code="\partial / \partial x"></tex-math> is the gradient operator with respect to <tex-math mode="inline" code="x"></tex-math>, as a column vector:</p><tex-math>\frac{\partial}{\partial x} = \left[ \frac{\partial}{\partial x_1} \frac{\partial}{\partial x_2} \dots \frac{\partial}{\partial x_n} \right]^\top</tex-math><p>Using this approximation, to minimize <tex-math mode="inline" code="E" maug="@E"></tex-math>, we set</p><tex-math maug="\begin{split}
  0 &amp;= \frac{\partial}{\partial @h} @E \\
  &amp;\approx \frac{\partial}{\partial @h} \sum_x \left[ @F(x) + @h \frac{\partial @F}{\partial x} - @G(x) \right]^2 \\
  &amp;= \sum_x 2 \frac{\partial @F}{\partial x} \left[ @F(x) + @h \frac{\partial @F}{\partial x} - @G(x) \right]
\end{split}">\begin{split}
  0 &amp;= \frac{\partial}{\partial h} E \\
  &amp;\approx \frac{\partial}{\partial h} \sum_x \left[ F(x) + h \frac{\partial F}{\partial x} - G(x) \right]^2 \\
  &amp;= \sum_x 2 \frac{\partial F}{\partial x} \left[ F(x) + h \frac{\partial F}{\partial x} - G(x) \right]
\end{split}</tex-math><p>from which</p><tex-math maug="@h = \left[ \sum_x \left( \frac{\partial @F}{\partial x} \right)^\top [@G(x) - @F(x)] \right] \left[ \sum_x \left( \frac{\partial @F}{\partial x} \right)^\top \frac{\partial @F}{\partial x} \right]^{-1}">h = \left[ \sum_x \left( \frac{\partial F}{\partial x} \right)^\top [G(x) - F(x)] \right] \left[ \sum_x \left( \frac{\partial F}{\partial x} \right)^\top \frac{\partial F}{\partial x} \right]^{-1}</tex-math><p>which has much the same form as the one-dimensional version in <cross-ref type="eqn" xref="e9" index="10"></cross-ref>.</p><p>The discussions above of iteration, weighting, smoothing, and the coarse-fine technique with respect to the onedimensional case apply to the n-dimensional case as well. Calculating our estimate of <tex-math mode="inline" code="h" maug="@h"></tex-math> in the two-dimensional case requires accumulating the weighted sum of five products <tex-math mode="inline" code="((G - F)F_x, (G - F)F_y, F^2_x, F^2_y, \text{and } F_x F_y)" maug="((@G - @F)@F_x, (@G - @F)@F_y, @F^2_x, @F^2_y, \text{and } @F_x @F_y)"></tex-math> over the region <tex-math mode="inline" code="R" maug="@R"></tex-math>, as opposed to accumulating one product for correlation or the <tex-math mode="inline" code="L_2"></tex-math> norm. However, this is more than compensated for, especially in high-resolution images, by evaluating these sums at fewer values of <tex-math mode="inline" code="h" maug="@h"></tex-math>.</p><h2 id="sec4.6" data-counter="4.6">Further generalizations</h2><p>Our technique can be extended to registration between two images related not by a simple translation, but by an arbitrary linear transformation, such as rotation, scaling, and shearing. Such a relationship is expressed by</p><tex-math maug="@G(x) = @F(x @A + @h)">G(x) = F(x A + h)</tex-math><p>where <tex-math mode="inline" code="A" maug="@A"></tex-math> is a matrix expressing the linear spatial tranformation between <tex-math mode="inline" code="F(x)" maug="@F(x)"></tex-math> and <tex-math mode="inline" code="G(x)" maug="@G(x)"></tex-math>. The quantity to be minimized in this case is</p><tex-math maug="@E = \sum_x [@F(x@A + @h) - @G(x)]^2">E = \sum_x [F(xA + h) - G(x)]^2</tex-math><p>To determine the amount <tex-math mode="inline" code="\Delta A" maug="\Delta @A"></tex-math> to adjust <tex-math mode="inline" code="A" maug="@A"></tex-math> and the amount <tex-math mode="inline" code="\Delta h" maug="\Delta @h"></tex-math> to adjust <tex-math mode="inline" code="h" maug="@h"></tex-math>, we use the linear approximation</p><tex-equation id="e11" maug="\begin{split}
  &amp; @F(x(@A + \Delta @A) + (@h + \Delta @h)) \\
  \approx&amp; @F(x@A + @h) + (x \Delta @A + \Delta @h) \frac{\partial}{\partial x} @F(x)
\end{split}" data-counter="12">\begin{split}
  &amp; F(x(A + \Delta A) + (h + \Delta h)) \\
  \approx&amp; F(xA + h) + (x \Delta A + \Delta h) \frac{\partial}{\partial x} F(x)
\end{split}</tex-equation><p>When we use this approximation the error expression again becomes quadratic in the quantities to be minimized with respect to. Differentiating with respect to these quantities and setting the results equal to zero yields a set of linear equations to be solved simultaneously.</p><p>This generalization is useful in applications such as stereovision, where the two different views of the object will be different views, due to the difference of the viewpoints of the cameras or to differences in the processing of the two images. If we model this difference as a linear transformation, we have (ignoring the registration problem for the moment)</p><tex-math maug="@F(x) = @\alpha @G(x) + @\beta">F(x) = \alpha G(x) + \beta</tex-math><p>where <tex-math mode="inline" code="\alpha" maug="@\alpha"></tex-math> may be thought of as a contrast adjustment and <tex-math mode="inline" code="\beta" maug="@\beta"></tex-math> as a brightness adjustment. Combining this with the general linear transformation registration problem, we obtain</p><tex-math maug="@E = \sum_x [@F(x@A + @h) - (@\alpha @G(x) + @\beta)]^2">E = \sum_x [F(xA + h) - (\alpha G(x) + \beta)]^2</tex-math><p>as the quantity to minimize with respect to <tex-math mode="inline" code="\alpha" maug="@\alpha"></tex-math>, <tex-math mode="inline" code="\beta" maug="@\beta"></tex-math>, <tex-math mode="inline" code="A" maug="@A"></tex-math>, and <tex-math mode="inline" code="h" maug="@h"></tex-math>. The minimization of this quantity, using the linear approximation in equation <cross-ref type="eqn" xref="e11" index="12"></cross-ref>, is straightforward. This is the general form promised in section <cross-ref type="sec" xref="sec2" index="2"></cross-ref>. If we ignore <tex-math mode="inline" code="A" maug="@A"></tex-math>, minimizing this quantity is equivalent to maximizing the correlation coefficient (see, for example, <span class="cite-list">[<cite-ref key="Dudewicz1976" index="3"></cite-ref>]</span>); if we ignore <tex-math mode="inline" code="\alpha" maug="@\alpha"></tex-math> and <tex-math mode="inline" code="\beta" maug="@\beta"></tex-math> as well, minimizing this form is equivalent to minimizing the <tex-math mode="inline" code="L_2"></tex-math> norm.</p><h1 id="sec5" data-counter="5">Application to stereo vision</h1><p>In this section we show how the generalized registration algorithm described above can be applied to extracting depth information from stereo images.</p><h2 id="sec5_1" data-counter="5.1">The stereo problem</h2><p>The problem of extracting depth information from a stereo pair has in principle four components: finding objects in the pictures, matching the objects in the two views, determining the camera parameters, and determining the distances from the camera to the objects. Our approach is to combine object matching with solving for the camera parameters and the distances of the objects by using a form of the fast registration technique described above.</p><p>Techniques for locating objects include an interest operator <span class="cite-list">[<cite-ref key="Moravec1979" index="6"></cite-ref>]</span>, zero crossings in bandpass-filtered images <span class="cite-list">[<cite-ref key="Marr1979" index="5"></cite-ref>]</span>, and linear features <span class="cite-list">[<cite-ref key="Baker1980" index="1"></cite-ref>]</span>. One might also use regions found by an image segmentation program as objects.</p><p>Stereo vision systems which work with features at the pixel level can use one of the registration techniques discussed above. Systems whose objects are higher-level features must use some difference measure and some search technique suited to the particular feature being used. Our registration algorithm provides a stereo vision system with a fast method of doing pixel-level matching.</p><p>Many stereo vision systems concern themselves only with calculating the distances to the matched objects. One must also be aware that in any real application of stereo vision the relative positions of the cameras will not be known with perfect accuracy. <cite-ref key="Gennery1979" mode="inline-author" index="4"></cite-ref> has shown how to simultaneously solve for the camera parameters and the distances of objects.</p><h2 id="sec5_2" data-counter="5.2">A mathematical characterization</h2><p>The notation we use is illustrated in <cross-ref type="fig" xref="fig3" index="3"></cross-ref>. Let <tex-math mode="inline" code="c"></tex-math> be the vector of camera parameters that describe the orientation and position of camera 2 with respect to camera 1’s coordinate system. These parameters are azimuth, elevation, pan, tilt, and roll, as defined in <cite-ref key="Gennery1979" mode="inline-author" index="4"></cite-ref>. Let <tex-math mode="inline" code="x" maug="@@x"></tex-math> denote the position of an image in the camera 1 film plane of an object. Suppose the object is at a distance <tex-math mode="inline" code="z" maug="@z"></tex-math> from camera 1. Given the position in picture 1 <tex-math mode="inline" code="x" maug="@@x"></tex-math> and distance <tex-math mode="inline" code="z" maug="@z"></tex-math> of the object, we could directly calculate the position <tex-math mode="inline" code="p(x, z)" maug="@p(@@x, @z)"></tex-math> that it must have occupied in three-space. We express <tex-math mode="inline" code="p" maug="@p"></tex-math> with respect to camera 1’s coordinate system so that <tex-math mode="inline" code="p"></tex-math> does not depend on the orientation of camera 1. The object would appear on camera 2’s film plane at a position <tex-math mode="inline" code="q(p, c)" maug="@q(@p, @c)"></tex-math> that is dependent on the object’s position in three-space <tex-math mode="inline" code="p" maug="@p"></tex-math> and on the camera parameters <tex-math mode="inline" code="c" maug="@c"></tex-math>. Let <tex-math mode="inline" code="G(x)" maug="@@G(@@x)"></tex-math> be the intensity value of pixel <tex-math mode="inline" code="x" maug="@@x"></tex-math> in picture 1, and let <tex-math mode="inline" code="F(q)" maug="@@F(@q)"></tex-math> the intensity value of pixel <tex-math mode="inline" code="q" maug="@q"></tex-math> in picture 2. The goal of a stereo vision system is to invert the relationship described above and solve for <tex-math mode="inline" code="c" maug="@c"></tex-math> and <tex-math mode="inline" code="z" maug="@z"></tex-math>, given <tex-math mode="inline" code="x" maug="@x"></tex-math>, <tex-math mode="inline" code="F" maug="@@F"></tex-math> and <tex-math mode="inline" code="G" maug="@@G"></tex-math>.</p><figure id="fig3" class="figure center" data-counter="3"><img width="50%" src="assets/fig3.svg"></img><figcaption data-counter="3">Stereo vision.</figcaption></figure><h2 id="sec5_3" data-counter="5.3">Applying the registration algorithm</h2><p>First consider the case where we know the exact camera parameters <tex-math mode="inline" code="c" maug="@c"></tex-math>, and we wish to discover the distance <tex-math mode="inline" code="z" maug="@z"></tex-math> of an object. Suppose we have an estimate of the distance <tex-math mode="inline" code="z" maug="@z"></tex-math>. We wish to see what happens to the quality of our match between <tex-math mode="inline" code="F" maug="@@F"></tex-math> and <tex-math mode="inline" code="G" maug="@@G"></tex-math> as we vary <tex-math mode="inline" code="z" maug="@z"></tex-math> by an amount <tex-math mode="inline" code="\Delta z" maug="\Delta @z"></tex-math>. The linear approximation that we use here is:</p><p><tex-math mode="inline" code="F(z + \Delta z) \approx F(z) + \Delta \frac{\partial F}{\partial z}" maug="@@F(@z + \Delta @z) \approx @@F(z) + \Delta \frac{\partial @@F}{\partial @z}"></tex-math>,</p><p>where</p><tex-equation id="e12" maug="\frac{\partial @@F}{\partial z} = \frac{\partial @p}{\partial @z} \frac{\partial @q}{\partial @p} \frac{\partial @@F}{\partial @q}" data-counter="13">\frac{\partial F}{\partial z} = \frac{\partial p}{\partial z} \frac{\partial q}{\partial p} \frac{\partial F}{\partial q}</tex-equation><p>This equation is due to the chain rule of the gradient operator; <tex-math mode="inline" code="\partial q / \partial p" maug="\partial @q / \partial @p"></tex-math> is a matrix of partial derivatives of the components of <tex-math mode="inline" code="q" maug="@q"></tex-math> with respect to the components of <tex-math mode="inline" code="p" maug="@p"></tex-math>, and <tex-math mode="inline" code="\partial F / \partial q" maug="\partial @F / \partial @q"></tex-math> is the spatial intensity gradient of the image <tex-math mode="inline" code="F(q)" maug="@F(@q)"></tex-math>. To update our estimate of <tex-math mode="inline" code="z" maug="@z"></tex-math>, we want to find the <tex-math mode="inline" code="\Delta z" maug="\Delta @z"></tex-math> which satisfies</p><tex-math maug="0 = \frac{\partial}{\partial \Delta @z} @E \approx \frac{\partial}{\partial \Delta @z} \sum_x [@@F + \Delta @z \frac{\partial @@F}{\partial \Delta @z} - @@G]^2">0 = \frac{\partial}{\partial \Delta z} E \approx \frac{\partial}{\partial \Delta z} \sum_x [F + \Delta z \frac{\partial F}{\partial \Delta z} - G]^2</tex-math><p>Solving for <tex-math mode="inline" code="\delta z" maug="\delta @z"></tex-math>, we obtain</p><tex-math maug="\delta @z = \sum_x \frac{\partial @@F}{\partial \Delta @z} [@@G - @@F] / \sum_x \left( \frac{\partial @@F}{\partial @z} \right)^2">\delta z = \sum_x \frac{\partial F}{\partial \Delta z} [G - F] / \sum_x \left( \frac{\partial F}{\partial z} \right)^2</tex-math><p>where <tex-math mode="inline" code="\frac{\partial F}{\partial z}" maug="\frac{\partial @@F}{\partial @z}"></tex-math> is given by <cross-ref type="eqn" xref="e12" index="13"></cross-ref>.</p><p>On the other hand. suppose we know the distances <tex-math mode="inline" code="z_i, i = 1, 2, \dots, n" maug="@z_i, i = 1, 2, \dots, n"></tex-math>, of each of <tex-math mode="inline" code="n"></tex-math> objects from camera 1, but we don’t know the exact camera parameters <tex-math mode="inline" code="c" maug="@c"></tex-math>. We wish to determine the effect of changing our estimate of the camera parameters by an amount <tex-math mode="inline" code="\Delta c" maug="\Delta @c"></tex-math>. Using the linear approximation</p><tex-math maug="@@F(@c + \Delta @c) \approx @@F(c) + \Delta @c \frac{\partial @q}{\partial @c} \frac{\partial @@F}{\partial @q}">F(c + \Delta c) \approx F(c) + \Delta c \frac{\partial q}{\partial c} \frac{\partial F}{\partial q}</tex-math><p>we solve the minimization of the error function with respect to <tex-math mode="inline" code="\Delta c" maug="\Delta @c"></tex-math> by setting</p><tex-math maug="0 = \frac{\partial}{\partial \Delta @c} \sum_i \sum_{x \varepsilon R_i} [@@F(@c + \Delta @c) - @@G]^2 \approx \frac{\partial}{\partial \Delta @c} \sum_i \sum_{x} [@@F + \Delta @c \frac{\partial @q}{\partial @c} \frac{\partial @@F}{\partial @q} - @@G]^2">0 = \frac{\partial}{\partial \Delta c} \sum_i \sum_{x \varepsilon R_i} [F(c + \Delta c) - G]^2 \approx \frac{\partial}{\partial \Delta c} \sum_i \sum_{x} [F + \Delta c \frac{\partial q}{\partial c} \frac{\partial F}{\partial q} - G]^2</tex-math><p>obtaining</p><tex-math maug="\Delta @c \approx \left[\sum_x \left(\frac{\partial @q}{\partial @c} \frac{\partial @@F}{\partial @q} \right)^\top [@@G - @@F] \right] \left[ \left(\frac{\partial @q}{\partial @c} \frac{\partial @@F}{\partial @q} \right)^\top \left(\frac{\partial @q}{\partial @c} \frac{\partial @@F}{\partial @q} \right) \right]^{-1}">\Delta c \approx \left[\sum_x \left(\frac{\partial q}{\partial c} \frac{\partial F}{\partial q} \right)^\top [G - F] \right] \left[ \left(\frac{\partial q}{\partial c} \frac{\partial F}{\partial q} \right)^\top \left(\frac{\partial q}{\partial c} \frac{\partial F}{\partial q} \right) \right]^{-1}</tex-math><p>As with the other techniques derived in this paper, weighting and iteration improve the solutions for <tex-math mode="inline" code="\Delta z" maug="\Delta @z"></tex-math> and <tex-math mode="inline" code="\Delta c" maug="\Delta @c"></tex-math> derived above.</p><h2 id="sec5_4" data-counter="5.4">An implementation</h2><div class="figures-aside margin"><figure id="fig4" class="figure" data-counter="4"><img width="100%" src="assets/fig4.png"></img><figcaption data-counter="4"></figcaption></figure><figure id="fig5" class="figure" data-counter="5"><img width="100%" src="assets/fig5.png"></img><figcaption data-counter="5"></figcaption></figure><figure id="fig6" class="figure" data-counter="6"><img width="100%" src="assets/fig6.png"></img><figcaption data-counter="6"></figcaption></figure><figure id="fig7" class="figure" data-counter="7"><img width="100%" src="assets/fig7.png"></img><figcaption data-counter="7"></figcaption></figure><figure id="fig8" class="figure" data-counter="8"><img width="100%" src="assets/fig8.png"></img><figcaption data-counter="8"></figcaption></figure><figure id="fig9" class="figure" data-counter="9"><img width="100%" src="assets/fig9.png"></img><figcaption data-counter="9"></figcaption></figure><figure id="fig10" class="figure" data-counter="10"><img width="100%" src="assets/fig10.png"></img><figcaption data-counter="10"></figcaption></figure></div><p>We have implemented the technique described above in a system which functions well under human supervision. Our program is capable of solving for the distances to the objects, the five camera parameters described above, and a brightness and contrast parameter for the entire scene, or any subset of these parameters. As one would expect from the discussion in section <cross-ref type="sec" xref="sec4_3" index="4.3"></cross-ref>, the algorithm will converge to the correct distances and camera parameters when the initial estimates of the <tex-math mode="inline" code="z_i" maug="@z_i"></tex-math>’s and <tex-math mode="inline" code="c" maug="@c"></tex-math> are sufficiently accurate that we know the position in the camera 2 film plane of each object to within a distance on the order of the size of the object.</p><p>A session with this program is illustrated in figures 4 through 10. The original stereo pair is presented in <cross-ref type="fig" xref="fig4" index="4"></cross-ref>. (Readers who can view stereo pairs cross-eyed will want to hold the pictures upside down so that each eye receives the correct view). The camera parameters were determined independently by hand-selecting matching points and solving for the parameters using the program described in <span class="cite-list">[<cite-ref key="Gennery1979" index="4"></cite-ref>]</span>.</p><p><cross-ref type="fig" xref="fig5" index="5"></cross-ref> and <cross-ref type="fig" xref="fig6" index="6"></cross-ref> are bandpass-flitered versions of the pictures in <cross-ref type="fig" xref="fig4" index="4"></cross-ref>. Bandpass-filtered images are preferred to lowpass-filtered images in finding matches because very low spatial frequencies tend to be a result of shading differences and carry no (or misleading) depth information. The two regions enclosed in rectangles in the left view of <cross-ref type="fig" xref="fig5" index="5"></cross-ref> have been hand-selected and assigned an initial depth of <tex-math mode="inline" code="7.0"></tex-math> in units of the distance between cameras. If these were the actual depths, the corresponding objects would be found in the right view at the positions indicated <cross-ref type="fig" xref="fig5" index="5"></cross-ref>. After seven depth-adjustment iterations, the program found the matches shown in <cross-ref type="fig" xref="fig6" index="6"></cross-ref>. The distances are <tex-math mode="inline" code="6.05"></tex-math> for object 1 and <tex-math mode="inline" code="5.86"></tex-math> for object 2.</p><p><cross-ref type="fig" xref="fig7" index="7"></cross-ref> and <cross-ref type="fig" xref="fig8" index="8"></cross-ref> are bandpass-filtered with a band one octave higher than <cross-ref type="fig" xref="fig5" index="5"></cross-ref> and <cross-ref type="fig" xref="fig6" index="6"></cross-ref>. Five new points have been hand-selected in the left view, reflecting the different features which have become visible in this spatial frequency range. Each has been assigned an initial depth equal to that found for the corresponding larger region in <cross-ref type="fig" xref="fig6" index="6"></cross-ref>. The predicted position corresponding to these depths is shown in the right view of <cross-ref type="fig" xref="fig7" index="7"></cross-ref>. After five depth-adjustment iterations, the matches shown in <cross-ref type="fig" xref="fig8" index="8"></cross-ref> were found. The corresponding depths are <tex-math mode="inline" code="5.96"></tex-math> for object 1, <tex-math mode="inline" code="5.98"></tex-math> for object 2, <tex-math mode="inline" code="5.77"></tex-math> for object 3, <tex-math mode="inline" code="5.78"></tex-math> for object 4, and <tex-math mode="inline" code="6.09"></tex-math> for object 5.</p><p><cross-ref type="fig" xref="fig9" index="9"></cross-ref> and <cross-ref type="fig" xref="fig10" index="10"></cross-ref> are bandpass-filtered with a band yet another octave higher than <cross-ref type="fig" xref="fig7" index="7"></cross-ref> and <cross-ref type="fig" xref="fig8" index="8"></cross-ref>. Again five new points have been hand-selected in the left view, reflecting the different features which have become visible in this spatial frequency range. Each has been assigned an initial depth equal to that found for the corresponding region in <cross-ref type="fig" xref="fig8" index="8"></cross-ref>. The predicted position corresponding to these depths is shown in the right view of <cross-ref type="fig" xref="fig9" index="9"></cross-ref>. After four depthadjustment iterations, the matches shown in <cross-ref type="fig" xref="fig10" index="10"></cross-ref> were found. The corresponding depths are <tex-math mode="inline" code="5.97"></tex-math> for object 1, <tex-math mode="inline" code="5.98"></tex-math> for object 2, <tex-math mode="inline" code="5.80"></tex-math> For object 3, <tex-math mode="inline" code="5.77"></tex-math> for object 4, and <tex-math mode="inline" code="5.98"></tex-math> for object 5.</p><h2 id="sec5_5" data-counter="5.5">Future research</h2><p>The system that we have implemented at present requires considerable hand-guidance. The following are the issues we intend to investigate toward the goal of automating the process.</p><ul><li><p>Providing initial depth estimates for objects: one should be able to use approximate depths obtained from low resolution images to provide initial depth estimates for nearby objects visible only at higher resolutions. This suggests a coarse-fine paradigm not just for the problem of finding individual matches but for the problem of extracting depth infortnation as a whole.</p></li><li><p>Constructing a depth map: one could construct a depth map from depth measurements by some interpolation method, and refine the depth map with depth measurements obtained from successively higher resolution views.</p></li><li><p>Selecting points of interest: the various techniques mentioned in section <cross-ref type="sec" xref="sec3" index="3"></cross-ref> should be explored.</p></li><li><p>Tracking sudden depth changes: the sudden depth changes found at the edges of objects require some set of higher-level heuristics to keep the matching algorithm on track at object boundaries.</p></li><li><p>Compensating for the different appearances of objects in the two views: the general form of the matching algorithm that allows for arbitrary linear transformations should be useful here.</p></li></ul><h1 id="sec6" data-counter="6">Acknowledgements</h1><p>We would like to thank Michael Horowitz, Richard Korf, and Pradeep Sindhu for their helpful comments on early drafts of this paper.</p><h1 nonumber="true">References</h1><ol class="references"><li id="ref-0">Baker, H. H. (1980). Edge Based Stereo Correlation. DARPA Image Understanding Workshop, 168–175.</li><li id="ref-1">Barnea, D. I., &amp; Silverman, H. F. (1972). A Class of Algorithms for Fast Digital Image Registration. IEEE Transactions on Computers, C–21, 179–186. <a href="https://doi.org/10.1109/TC.1972.5008923">https://doi.org/10.1109/TC.1972.5008923</a></li><li id="ref-2">Dudewicz, E. J. (1976). Introduction to statistics and probability. Holt, Rinehart.</li><li id="ref-3">Gennery, D. B. (1979). Stereo-Camera Calibration. DARPA Image Understanding Workshop, 101–107.</li><li id="ref-4">Marr, D., &amp; Poggio, T. A. (1979). A computational theory of human stereo vision. Proceedings of the Royal Society of London. Series B, Biological Sciences, 204 1156, 301–328. <a href="https://doi.org/10.1016/B978-1-4832-1446-7.50046-7">https://doi.org/10.1016/B978-1-4832-1446-7.50046-7</a></li><li id="ref-5">Moravec, H. P. (1979). Visual Mapping by a Robot Rover. IJCAI. <a href="https://doi.org/10.5555/1624861.1624997">https://doi.org/10.5555/1624861.1624997</a></li><li id="ref-6">Nilsson, N. J. (1971). Problem-solving methods in artificial intelligence. McGraw-Hill Computer Science Series. <a href="https://doi.org/10.1145/1056578.1056583">https://doi.org/10.1145/1056578.1056583</a></li></ol></article>
    <script type="module">
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const e=window,t=e.ShadowRoot&&(void 0===e.ShadyCSS||e.ShadyCSS.nativeShadow)&&"adoptedStyleSheets"in Document.prototype&&"replace"in CSSStyleSheet.prototype,n=Symbol(),r=new WeakMap;const i=e=>new class{constructor(e,t,r){if(this._$cssResult$=!0,r!==n)throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");this.cssText=e,this.t=t}get styleSheet(){let e=this.o;const n=this.t;if(t&&void 0===e){const t=void 0!==n&&1===n.length;t&&(e=r.get(n)),void 0===e&&((this.o=e=new CSSStyleSheet).replaceSync(this.cssText),t&&r.set(n,e))}return e}toString(){return this.cssText}}("string"==typeof e?e:e+"",void 0,n),o=t?e=>e:e=>e instanceof CSSStyleSheet?(e=>{let t="";for(const n of e.cssRules)t+=n.cssText;return i(t)})(e):e
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */;var s;const a=window,l=a.trustedTypes,c=l?l.emptyScript:"",u=a.reactiveElementPolyfillSupport,d={toAttribute(e,t){switch(t){case Boolean:e=e?c:null;break;case Object:case Array:e=null==e?e:JSON.stringify(e)}return e},fromAttribute(e,t){let n=e;switch(t){case Boolean:n=null!==e;break;case Number:n=null===e?null:Number(e);break;case Object:case Array:try{n=JSON.parse(e)}catch(e){n=null}}return n}},h=(e,t)=>t!==e&&(t==t||e==e),f={attribute:!0,type:String,converter:d,reflect:!1,hasChanged:h};let p=class extends HTMLElement{constructor(){super(),this._$Ei=new Map,this.isUpdatePending=!1,this.hasUpdated=!1,this._$El=null,this.u()}static addInitializer(e){var t;this.finalize(),(null!==(t=this.h)&&void 0!==t?t:this.h=[]).push(e)}static get observedAttributes(){this.finalize();const e=[];return this.elementProperties.forEach(((t,n)=>{const r=this._$Ep(n,t);void 0!==r&&(this._$Ev.set(r,n),e.push(r))})),e}static createProperty(e,t=f){if(t.state&&(t.attribute=!1),this.finalize(),this.elementProperties.set(e,t),!t.noAccessor&&!this.prototype.hasOwnProperty(e)){const n="symbol"==typeof e?Symbol():"__"+e,r=this.getPropertyDescriptor(e,n,t);void 0!==r&&Object.defineProperty(this.prototype,e,r)}}static getPropertyDescriptor(e,t,n){return{get(){return this[t]},set(r){const i=this[e];this[t]=r,this.requestUpdate(e,i,n)},configurable:!0,enumerable:!0}}static getPropertyOptions(e){return this.elementProperties.get(e)||f}static finalize(){if(this.hasOwnProperty("finalized"))return!1;this.finalized=!0;const e=Object.getPrototypeOf(this);if(e.finalize(),void 0!==e.h&&(this.h=[...e.h]),this.elementProperties=new Map(e.elementProperties),this._$Ev=new Map,this.hasOwnProperty("properties")){const e=this.properties,t=[...Object.getOwnPropertyNames(e),...Object.getOwnPropertySymbols(e)];for(const n of t)this.createProperty(n,e[n])}return this.elementStyles=this.finalizeStyles(this.styles),!0}static finalizeStyles(e){const t=[];if(Array.isArray(e)){const n=new Set(e.flat(1/0).reverse());for(const e of n)t.unshift(o(e))}else void 0!==e&&t.push(o(e));return t}static _$Ep(e,t){const n=t.attribute;return!1===n?void 0:"string"==typeof n?n:"string"==typeof e?e.toLowerCase():void 0}u(){var e;this._$E_=new Promise((e=>this.enableUpdating=e)),this._$AL=new Map,this._$Eg(),this.requestUpdate(),null===(e=this.constructor.h)||void 0===e||e.forEach((e=>e(this)))}addController(e){var t,n;(null!==(t=this._$ES)&&void 0!==t?t:this._$ES=[]).push(e),void 0!==this.renderRoot&&this.isConnected&&(null===(n=e.hostConnected)||void 0===n||n.call(e))}removeController(e){var t;null===(t=this._$ES)||void 0===t||t.splice(this._$ES.indexOf(e)>>>0,1)}_$Eg(){this.constructor.elementProperties.forEach(((e,t)=>{this.hasOwnProperty(t)&&(this._$Ei.set(t,this[t]),delete this[t])}))}createRenderRoot(){var n;const r=null!==(n=this.shadowRoot)&&void 0!==n?n:this.attachShadow(this.constructor.shadowRootOptions);return((n,r)=>{t?n.adoptedStyleSheets=r.map((e=>e instanceof CSSStyleSheet?e:e.styleSheet)):r.forEach((t=>{const r=document.createElement("style"),i=e.litNonce;void 0!==i&&r.setAttribute("nonce",i),r.textContent=t.cssText,n.appendChild(r)}))})(r,this.constructor.elementStyles),r}connectedCallback(){var e;void 0===this.renderRoot&&(this.renderRoot=this.createRenderRoot()),this.enableUpdating(!0),null===(e=this._$ES)||void 0===e||e.forEach((e=>{var t;return null===(t=e.hostConnected)||void 0===t?void 0:t.call(e)}))}enableUpdating(e){}disconnectedCallback(){var e;null===(e=this._$ES)||void 0===e||e.forEach((e=>{var t;return null===(t=e.hostDisconnected)||void 0===t?void 0:t.call(e)}))}attributeChangedCallback(e,t,n){this._$AK(e,n)}_$EO(e,t,n=f){var r;const i=this.constructor._$Ep(e,n);if(void 0!==i&&!0===n.reflect){const o=(void 0!==(null===(r=n.converter)||void 0===r?void 0:r.toAttribute)?n.converter:d).toAttribute(t,n.type);this._$El=e,null==o?this.removeAttribute(i):this.setAttribute(i,o),this._$El=null}}_$AK(e,t){var n;const r=this.constructor,i=r._$Ev.get(e);if(void 0!==i&&this._$El!==i){const e=r.getPropertyOptions(i),o="function"==typeof e.converter?{fromAttribute:e.converter}:void 0!==(null===(n=e.converter)||void 0===n?void 0:n.fromAttribute)?e.converter:d;this._$El=i,this[i]=o.fromAttribute(t,e.type),this._$El=null}}requestUpdate(e,t,n){let r=!0;void 0!==e&&(((n=n||this.constructor.getPropertyOptions(e)).hasChanged||h)(this[e],t)?(this._$AL.has(e)||this._$AL.set(e,t),!0===n.reflect&&this._$El!==e&&(void 0===this._$EC&&(this._$EC=new Map),this._$EC.set(e,n))):r=!1),!this.isUpdatePending&&r&&(this._$E_=this._$Ej())}async _$Ej(){this.isUpdatePending=!0;try{await this._$E_}catch(e){Promise.reject(e)}const e=this.scheduleUpdate();return null!=e&&await e,!this.isUpdatePending}scheduleUpdate(){return this.performUpdate()}performUpdate(){var e;if(!this.isUpdatePending)return;this.hasUpdated,this._$Ei&&(this._$Ei.forEach(((e,t)=>this[t]=e)),this._$Ei=void 0);let t=!1;const n=this._$AL;try{t=this.shouldUpdate(n),t?(this.willUpdate(n),null===(e=this._$ES)||void 0===e||e.forEach((e=>{var t;return null===(t=e.hostUpdate)||void 0===t?void 0:t.call(e)})),this.update(n)):this._$Ek()}catch(e){throw t=!1,this._$Ek(),e}t&&this._$AE(n)}willUpdate(e){}_$AE(e){var t;null===(t=this._$ES)||void 0===t||t.forEach((e=>{var t;return null===(t=e.hostUpdated)||void 0===t?void 0:t.call(e)})),this.hasUpdated||(this.hasUpdated=!0,this.firstUpdated(e)),this.updated(e)}_$Ek(){this._$AL=new Map,this.isUpdatePending=!1}get updateComplete(){return this.getUpdateComplete()}getUpdateComplete(){return this._$E_}shouldUpdate(e){return!0}update(e){void 0!==this._$EC&&(this._$EC.forEach(((e,t)=>this._$EO(t,this[t],e))),this._$EC=void 0),this._$Ek()}updated(e){}firstUpdated(e){}};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var m;p.finalized=!0,p.elementProperties=new Map,p.elementStyles=[],p.shadowRootOptions={mode:"open"},null==u||u({ReactiveElement:p}),(null!==(s=a.reactiveElementVersions)&&void 0!==s?s:a.reactiveElementVersions=[]).push("1.6.1");const y=window,v=y.trustedTypes,b=v?v.createPolicy("lit-html",{createHTML:e=>e}):void 0,w="$lit$",g=`lit$${(Math.random()+"").slice(9)}$`,_="?"+g,$=`<${_}>`,E=document,A=()=>E.createComment(""),x=e=>null===e||"object"!=typeof e&&"function"!=typeof e,S=Array.isArray,k="[ \t\n\f\r]",C=/<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,T=/-->/g,N=/>/g,j=RegExp(`>|${k}(?:([^\\s"'>=/]+)(${k}*=${k}*(?:[^ \t\n\f\r"'\`<>=]|("|')|))|$)`,"g"),R=/'/g,O=/"/g,P=/^(?:script|style|textarea|title)$/i,I=(e=>(t,...n)=>({_$litType$:e,strings:t,values:n}))(1),M=Symbol.for("lit-noChange"),L=Symbol.for("lit-nothing"),D=new WeakMap,q=E.createTreeWalker(E,129,null,!1),U=(e,t)=>{const n=e.length-1,r=[];let i,o=2===t?"<svg>":"",s=C;for(let t=0;t<n;t++){const n=e[t];let a,l,c=-1,u=0;for(;u<n.length&&(s.lastIndex=u,l=s.exec(n),null!==l);)u=s.lastIndex,s===C?"!--"===l[1]?s=T:void 0!==l[1]?s=N:void 0!==l[2]?(P.test(l[2])&&(i=RegExp("</"+l[2],"g")),s=j):void 0!==l[3]&&(s=j):s===j?">"===l[0]?(s=null!=i?i:C,c=-1):void 0===l[1]?c=-2:(c=s.lastIndex-l[2].length,a=l[1],s=void 0===l[3]?j:'"'===l[3]?O:R):s===O||s===R?s=j:s===T||s===N?s=C:(s=j,i=void 0);const d=s===j&&e[t+1].startsWith("/>")?" ":"";o+=s===C?n+$:c>=0?(r.push(a),n.slice(0,c)+w+n.slice(c)+g+d):n+g+(-2===c?(r.push(void 0),t):d)}const a=o+(e[n]||"<?>")+(2===t?"</svg>":"");if(!Array.isArray(e)||!e.hasOwnProperty("raw"))throw Error("invalid template strings array");return[void 0!==b?b.createHTML(a):a,r]};class B{constructor({strings:e,_$litType$:t},n){let r;this.parts=[];let i=0,o=0;const s=e.length-1,a=this.parts,[l,c]=U(e,t);if(this.el=B.createElement(l,n),q.currentNode=this.el.content,2===t){const e=this.el.content,t=e.firstChild;t.remove(),e.append(...t.childNodes)}for(;null!==(r=q.nextNode())&&a.length<s;){if(1===r.nodeType){if(r.hasAttributes()){const e=[];for(const t of r.getAttributeNames())if(t.endsWith(w)||t.startsWith(g)){const n=c[o++];if(e.push(t),void 0!==n){const e=r.getAttribute(n.toLowerCase()+w).split(g),t=/([.?@])?(.*)/.exec(n);a.push({type:1,index:i,name:t[2],strings:e,ctor:"."===t[1]?G:"?"===t[1]?J:"@"===t[1]?Y:W})}else a.push({type:6,index:i})}for(const t of e)r.removeAttribute(t)}if(P.test(r.tagName)){const e=r.textContent.split(g),t=e.length-1;if(t>0){r.textContent=v?v.emptyScript:"";for(let n=0;n<t;n++)r.append(e[n],A()),q.nextNode(),a.push({type:2,index:++i});r.append(e[t],A())}}}else if(8===r.nodeType)if(r.data===_)a.push({type:2,index:i});else{let e=-1;for(;-1!==(e=r.data.indexOf(g,e+1));)a.push({type:7,index:i}),e+=g.length-1}i++}}static createElement(e,t){const n=E.createElement("template");return n.innerHTML=e,n}}function F(e,t,n=e,r){var i,o,s,a;if(t===M)return t;let l=void 0!==r?null===(i=n._$Co)||void 0===i?void 0:i[r]:n._$Cl;const c=x(t)?void 0:t._$litDirective$;return(null==l?void 0:l.constructor)!==c&&(null===(o=null==l?void 0:l._$AO)||void 0===o||o.call(l,!1),void 0===c?l=void 0:(l=new c(e),l._$AT(e,n,r)),void 0!==r?(null!==(s=(a=n)._$Co)&&void 0!==s?s:a._$Co=[])[r]=l:n._$Cl=l),void 0!==l&&(t=F(e,l._$AS(e,t.values),l,r)),t}class H{constructor(e,t){this.u=[],this._$AN=void 0,this._$AD=e,this._$AM=t}get parentNode(){return this._$AM.parentNode}get _$AU(){return this._$AM._$AU}v(e){var t;const{el:{content:n},parts:r}=this._$AD,i=(null!==(t=null==e?void 0:e.creationScope)&&void 0!==t?t:E).importNode(n,!0);q.currentNode=i;let o=q.nextNode(),s=0,a=0,l=r[0];for(;void 0!==l;){if(s===l.index){let t;2===l.type?t=new z(o,o.nextSibling,this,e):1===l.type?t=new l.ctor(o,l.name,l.strings,this,e):6===l.type&&(t=new Z(o,this,e)),this.u.push(t),l=r[++a]}s!==(null==l?void 0:l.index)&&(o=q.nextNode(),s++)}return i}p(e){let t=0;for(const n of this.u)void 0!==n&&(void 0!==n.strings?(n._$AI(e,n,t),t+=n.strings.length-2):n._$AI(e[t])),t++}}class z{constructor(e,t,n,r){var i;this.type=2,this._$AH=L,this._$AN=void 0,this._$AA=e,this._$AB=t,this._$AM=n,this.options=r,this._$Cm=null===(i=null==r?void 0:r.isConnected)||void 0===i||i}get _$AU(){var e,t;return null!==(t=null===(e=this._$AM)||void 0===e?void 0:e._$AU)&&void 0!==t?t:this._$Cm}get parentNode(){let e=this._$AA.parentNode;const t=this._$AM;return void 0!==t&&11===(null==e?void 0:e.nodeType)&&(e=t.parentNode),e}get startNode(){return this._$AA}get endNode(){return this._$AB}_$AI(e,t=this){e=F(this,e,t),x(e)?e===L||null==e||""===e?(this._$AH!==L&&this._$AR(),this._$AH=L):e!==this._$AH&&e!==M&&this.g(e):void 0!==e._$litType$?this.$(e):void 0!==e.nodeType?this.T(e):(e=>S(e)||"function"==typeof(null==e?void 0:e[Symbol.iterator]))(e)?this.k(e):this.g(e)}S(e){return this._$AA.parentNode.insertBefore(e,this._$AB)}T(e){this._$AH!==e&&(this._$AR(),this._$AH=this.S(e))}g(e){this._$AH!==L&&x(this._$AH)?this._$AA.nextSibling.data=e:this.T(E.createTextNode(e)),this._$AH=e}$(e){var t;const{values:n,_$litType$:r}=e,i="number"==typeof r?this._$AC(e):(void 0===r.el&&(r.el=B.createElement(r.h,this.options)),r);if((null===(t=this._$AH)||void 0===t?void 0:t._$AD)===i)this._$AH.p(n);else{const e=new H(i,this),t=e.v(this.options);e.p(n),this.T(t),this._$AH=e}}_$AC(e){let t=D.get(e.strings);return void 0===t&&D.set(e.strings,t=new B(e)),t}k(e){S(this._$AH)||(this._$AH=[],this._$AR());const t=this._$AH;let n,r=0;for(const i of e)r===t.length?t.push(n=new z(this.S(A()),this.S(A()),this,this.options)):n=t[r],n._$AI(i),r++;r<t.length&&(this._$AR(n&&n._$AB.nextSibling,r),t.length=r)}_$AR(e=this._$AA.nextSibling,t){var n;for(null===(n=this._$AP)||void 0===n||n.call(this,!1,!0,t);e&&e!==this._$AB;){const t=e.nextSibling;e.remove(),e=t}}setConnected(e){var t;void 0===this._$AM&&(this._$Cm=e,null===(t=this._$AP)||void 0===t||t.call(this,e))}}class W{constructor(e,t,n,r,i){this.type=1,this._$AH=L,this._$AN=void 0,this.element=e,this.name=t,this._$AM=r,this.options=i,n.length>2||""!==n[0]||""!==n[1]?(this._$AH=Array(n.length-1).fill(new String),this.strings=n):this._$AH=L}get tagName(){return this.element.tagName}get _$AU(){return this._$AM._$AU}_$AI(e,t=this,n,r){const i=this.strings;let o=!1;if(void 0===i)e=F(this,e,t,0),o=!x(e)||e!==this._$AH&&e!==M,o&&(this._$AH=e);else{const r=e;let s,a;for(e=i[0],s=0;s<i.length-1;s++)a=F(this,r[n+s],t,s),a===M&&(a=this._$AH[s]),o||(o=!x(a)||a!==this._$AH[s]),a===L?e=L:e!==L&&(e+=(null!=a?a:"")+i[s+1]),this._$AH[s]=a}o&&!r&&this.j(e)}j(e){e===L?this.element.removeAttribute(this.name):this.element.setAttribute(this.name,null!=e?e:"")}}class G extends W{constructor(){super(...arguments),this.type=3}j(e){this.element[this.name]=e===L?void 0:e}}const V=v?v.emptyScript:"";class J extends W{constructor(){super(...arguments),this.type=4}j(e){e&&e!==L?this.element.setAttribute(this.name,V):this.element.removeAttribute(this.name)}}class Y extends W{constructor(e,t,n,r,i){super(e,t,n,r,i),this.type=5}_$AI(e,t=this){var n;if((e=null!==(n=F(this,e,t,0))&&void 0!==n?n:L)===M)return;const r=this._$AH,i=e===L&&r!==L||e.capture!==r.capture||e.once!==r.once||e.passive!==r.passive,o=e!==L&&(r===L||i);i&&this.element.removeEventListener(this.name,this,r),o&&this.element.addEventListener(this.name,this,e),this._$AH=e}handleEvent(e){var t,n;"function"==typeof this._$AH?this._$AH.call(null!==(n=null===(t=this.options)||void 0===t?void 0:t.host)&&void 0!==n?n:this.element,e):this._$AH.handleEvent(e)}}class Z{constructor(e,t,n){this.element=e,this.type=6,this._$AN=void 0,this._$AM=t,this.options=n}get _$AU(){return this._$AM._$AU}_$AI(e){F(this,e)}}const K=y.litHtmlPolyfillSupport;null==K||K(B,z),(null!==(m=y.litHtmlVersions)&&void 0!==m?m:y.litHtmlVersions=[]).push("2.7.0");
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var X,Q;class ee extends p{constructor(){super(...arguments),this.renderOptions={host:this},this._$Do=void 0}createRenderRoot(){var e,t;const n=super.createRenderRoot();return null!==(e=(t=this.renderOptions).renderBefore)&&void 0!==e||(t.renderBefore=n.firstChild),n}update(e){const t=this.render();this.hasUpdated||(this.renderOptions.isConnected=this.isConnected),super.update(e),this._$Do=((e,t,n)=>{var r,i;const o=null!==(r=null==n?void 0:n.renderBefore)&&void 0!==r?r:t;let s=o._$litPart$;if(void 0===s){const e=null!==(i=null==n?void 0:n.renderBefore)&&void 0!==i?i:null;o._$litPart$=s=new z(t.insertBefore(A(),e),e,void 0,null!=n?n:{})}return s._$AI(e),s})(t,this.renderRoot,this.renderOptions)}connectedCallback(){var e;super.connectedCallback(),null===(e=this._$Do)||void 0===e||e.setConnected(!0)}disconnectedCallback(){var e;super.disconnectedCallback(),null===(e=this._$Do)||void 0===e||e.setConnected(!1)}render(){return M}}ee.finalized=!0,ee._$litElement$=!0,null===(X=globalThis.litElementHydrateSupport)||void 0===X||X.call(globalThis,{LitElement:ee});const te=globalThis.litElementPolyfillSupport;null==te||te({LitElement:ee}),(null!==(Q=globalThis.litElementVersions)&&void 0!==Q?Q:globalThis.litElementVersions=[]).push("3.3.0");class ne extends ee{createRenderRoot(){return this}connectedCallback(){this.__initchildnodes||(this.__initchildnodes=!0,this.initialChildNodes(Array.from(this.childNodes,(e=>(e.__element=this,e)))),function(e,t=0){const n=e.childNodes;let r=n.length;for(;r>t;)e.removeChild(n[--r])}(this)),super.connectedCallback()}initialChildNodes(e){this.__children=e}articleData(){let e=this;for(;"ARTICLE"!==e.tagName;e=e.parentNode||e.__element);return e?.__data}}class re extends ne{constructor(){super(),this.visible=!1,this.addEventListener("keydown",this.keyDown),this.addEventListener("mousedown",this.mouseDown)}mouseDownClose=e=>{this.contains(e.target)||this.hide()};keyDownClose=e=>{oe(e.key)&&this.hide()};keyDown(e){ie(e.key)&&!this.visible&&this.show()}mouseDown(){this.visible||this.show()}hide(){this.querySelector(".tooltip").style.display="none",this.visible=!1,document.removeEventListener("keydown",this.keyDownClose),document.removeEventListener("mousedown",this.mouseDownClose)}show(){const e=this.getBoundingClientRect(),t=this.querySelector(".tooltip");t.style.display="inline-block",this.visible=!0,function(e,t){t.style.transform="translate(0, 0)";const n=t.getBoundingClientRect(),r=n.width,i=n.left,o=e.left,s=document.body.clientWidth-16,a=r>s?-i:o+r>s?s-(i+r):o-i,l=e.bottom-n.top+2;t.style.transform=`translate(${a}px, ${l}px)`}(e,t),document.addEventListener("keydown",this.keyDownClose),document.addEventListener("mousedown",this.mouseDownClose)}renderWithTooltip(e,t,n){const r=I`<div class="tooltip">${n}</div>`;return I`<span class=${e} tabindex=0>${r}${t}</span>`}}const ie=(e,t="Enter")=>e===t,oe=(e,t="Escape")=>e===t;function se(e){return(e||[]).map((({given:e,family:t})=>e?`${e.includes(".")?e:e[0]+"."} ${t}`:t))}function ae(){this.querySelector(".cite-author-expand").style.display="none",this.querySelector(".cite-author-hidden").style.display="inline"}function le(){this.querySelector(".cite-author-expand").style.display="inline",this.querySelector(".cite-author-hidden").style.display="none"}const ce="tag";function ue(e,t){if(t.className===ce)return;const n=t.cloneNode();if(n.id&&n.removeAttribute("id"),e.append(n),!fe(t))for(const e of t.childNodes)ue(n,e)}const de={SECTION:"sec",FIGURE:"fig",TABLE:"tbl",EQUATION:"eqn"},he=new Set(["CITE-REF","CODE-BLOCK","CROSS-REF","INLINE-NOTE","RANGE-TEXT","TEX-MATH"]),fe=e=>he.has(e.tagName);const{getPrototypeOf:pe,getOwnPropertyDescriptors:me}=Object;pe({});var ye={},ve={};function be(e){return new Function("d","return {"+e.map((function(e,t){return JSON.stringify(e)+": d["+t+'] || ""'})).join(",")+"}")}function we(e){var t=Object.create(null),n=[];return e.forEach((function(e){for(var r in e)r in t||n.push(t[r]=r)})),n}function ge(e,t){var n=e+"",r=n.length;return r<t?new Array(t-r+1).join(0)+n:n}function _e(e){var t,n=e.getUTCHours(),r=e.getUTCMinutes(),i=e.getUTCSeconds(),o=e.getUTCMilliseconds();return isNaN(e)?"Invalid Date":((t=e.getUTCFullYear())<0?"-"+ge(-t,6):t>9999?"+"+ge(t,6):ge(t,4))+"-"+ge(e.getUTCMonth()+1,2)+"-"+ge(e.getUTCDate(),2)+(o?"T"+ge(n,2)+":"+ge(r,2)+":"+ge(i,2)+"."+ge(o,3)+"Z":i?"T"+ge(n,2)+":"+ge(r,2)+":"+ge(i,2)+"Z":r||n?"T"+ge(n,2)+":"+ge(r,2)+"Z":"")}function $e(e){var t=new RegExp('["'+e+"\n\r]"),n=e.charCodeAt(0);function r(e,t){var r,i=[],o=e.length,s=0,a=0,l=o<=0,c=!1;function u(){if(l)return ve;if(c)return c=!1,ye;var t,r,i=s;if(34===e.charCodeAt(i)){for(;s++<o&&34!==e.charCodeAt(s)||34===e.charCodeAt(++s););return(t=s)>=o?l=!0:10===(r=e.charCodeAt(s++))?c=!0:13===r&&(c=!0,10===e.charCodeAt(s)&&++s),e.slice(i+1,t-1).replace(/""/g,'"')}for(;s<o;){if(10===(r=e.charCodeAt(t=s++)))c=!0;else if(13===r)c=!0,10===e.charCodeAt(s)&&++s;else if(r!==n)continue;return e.slice(i,t)}return l=!0,e.slice(i,o)}for(10===e.charCodeAt(o-1)&&--o,13===e.charCodeAt(o-1)&&--o;(r=u())!==ve;){for(var d=[];r!==ye&&r!==ve;)d.push(r),r=u();t&&null==(d=t(d,a++))||i.push(d)}return i}function i(t,n){return t.map((function(t){return n.map((function(e){return s(t[e])})).join(e)}))}function o(t){return t.map(s).join(e)}function s(e){return null==e?"":e instanceof Date?_e(e):t.test(e+="")?'"'+e.replace(/"/g,'""')+'"':e}return{parse:function(e,t){var n,i,o=r(e,(function(e,r){if(n)return n(e,r-1);i=e,n=t?function(e,t){var n=be(e);return function(r,i){return t(n(r),i,e)}}(e,t):be(e)}));return o.columns=i||[],o},parseRows:r,format:function(t,n){return null==n&&(n=we(t)),[n.map(s).join(e)].concat(i(t,n)).join("\n")},formatBody:function(e,t){return null==t&&(t=we(e)),i(e,t).join("\n")},formatRows:function(e){return e.map(o).join("\n")},formatRow:o,formatValue:s}}var Ee=$e(","),Ae=Ee.parse,xe=Ee.parseRows,Se=$e("\t"),ke=Se.parse,Ce=Se.parseRows;function Te(e){for(var t in e){var n,r,i=e[t].trim();if(i)if("true"===i)i=!0;else if("false"===i)i=!1;else if("NaN"===i)i=NaN;else if(isNaN(n=+i)){if(!(r=i.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)))continue;Ne&&r[4]&&!r[7]&&(i=i.replace(/-/g,"/").replace(/T/," ")),i=new Date(i)}else i=n;else i=null;e[t]=i}return e}const Ne=new Date("2019-01-01T00:00").getHours()||new Date("2019-07-01T00:00").getHours();function je(e,t,n){return{resolve:(r=n)=>`${e}@${t}/${r}`}}const Re=je("d3","7.8.4","dist/d3.min.js"),Oe=je("@observablehq/inputs","0.10.4","dist/inputs.min.js"),Pe=je("@observablehq/plot","0.6.5","dist/plot.umd.min.js"),Ie=je("@observablehq/graphviz","0.2.1","dist/graphviz.min.js"),Me=je("@observablehq/highlight.js","2.0.0","highlight.min.js"),Le=je("@observablehq/katex","0.11.1","dist/katex.min.js"),De=je("lodash","4.17.21","lodash.min.js"),qe=je("htl","0.3.1","dist/htl.min.js"),Ue=je("jszip","3.10.1","dist/jszip.min.js"),Be=je("marked","0.3.12","marked.min.js"),Fe=je("sql.js","1.8.0","dist/sql-wasm.js"),He=je("vega","5.22.1","build/vega.min.js"),ze=je("vega-lite","5.6.0","build/vega-lite.min.js"),We=je("vega-lite-api","5.0.0","build/vega-lite-api.min.js"),Ge=je("apache-arrow","4.0.1","Arrow.es2015.min.js"),Ve=je("apache-arrow","9.0.0","+esm"),Je=je("apache-arrow","11.0.0","+esm"),Ye=je("arquero","4.8.8","dist/arquero.min.js"),Ze=je("topojson-client","3.1.0","dist/topojson-client.min.js"),Ke=je("exceljs","4.3.0","dist/exceljs.min.js"),Xe=je("mermaid","9.2.2","dist/mermaid.min.js"),Qe=je("leaflet","1.9.3","dist/leaflet.js"),et=je("@duckdb/duckdb-wasm","1.24.0","+esm"),tt=new Map,nt=[],rt=nt.map,it=nt.some,ot=nt.hasOwnProperty,st=/^((?:@[^/@]+\/)?[^/@]+)(?:@([^/]+))?(?:\/(.*))?$/,at=/^\d+\.\d+\.\d+(-[\w-.+]+)?$/,lt=/(?:\.[^/]*|\/)$/;class ct extends Error{constructor(e){super(e)}}function ut(e){const t=st.exec(e);return t&&{name:t[1],version:t[2],path:t[3]}}function dt(e="https://cdn.jsdelivr.net/npm/",t=["unpkg","jsdelivr","browser","main"]){if(!/\/$/.test(e))throw new Error("origin lacks trailing slash");function n(t){const n=`${e}${t.name}${t.version?`@${t.version}`:""}/package.json`;let r=tt.get(n);return r||tt.set(n,r=fetch(n).then((e=>{if(!e.ok)throw new ct("unable to load package.json");return e.redirected&&!tt.has(e.url)&&tt.set(e.url,r),e.json()}))),r}return async function(r,i){if(r.startsWith(e)&&(r=r.substring(e.length)),/^(\w+:)|\/\//i.test(r))return r;if(/^[.]{0,2}\//i.test(r))return new URL(r,i??location).href;if(!r.length||/^[\s._]/.test(r)||/\s$/.test(r))throw new ct("illegal name");const o=ut(r);if(!o)return`${e}${r}`;if(!o.version&&null!=i&&i.startsWith(e)){const t=await n(ut(i.substring(e.length)));o.version=t.dependencies&&t.dependencies[o.name]||t.peerDependencies&&t.peerDependencies[o.name]}if(o.path&&!lt.test(o.path)&&(o.path+=".js"),o.path&&o.version&&at.test(o.version))return`${e}${o.name}@${o.version}/${o.path}`;const s=await n(o);return`${e}${s.name}@${s.version}/${o.path||function(e){for(const n of t){let t=e[n];if("string"==typeof t)return t.startsWith("./")&&(t=t.slice(2)),lt.test(t)?t:`${t}.js`}}(s)||"index.js"}`}}ct.prototype.name=ct.name;var ht=ft(dt());function ft(e){const t=new Map,n=i(null);function r(e){if("string"!=typeof e)return e;let n=t.get(e);return n||t.set(e,n=new Promise(((t,n)=>{const r=document.createElement("script");r.onload=()=>{try{t(nt.pop()(i(e)))}catch(e){n(new ct("invalid module"))}r.remove()},r.onerror=()=>{n(new ct("unable to load module")),r.remove()},r.async=!0,r.src=e,window.define=vt,document.head.appendChild(r)}))),n}function i(t){return n=>Promise.resolve(e(n,t)).then(r)}function o(e){return arguments.length>1?Promise.all(rt.call(arguments,n)).then(pt):n(e)}return o.alias=function(t){return ft(((n,r)=>n in t&&(r=null,"string"!=typeof(n=t[n]))?n:e(n,r)))},o.resolve=e,o}function pt(e){const t={};for(const n of e)for(const e in n)ot.call(n,e)&&(null==n[e]?Object.defineProperty(t,e,{get:mt(n,e)}):t[e]=n[e]);return t}function mt(e,t){return()=>e[t]}function yt(e){return"exports"===(e+="")||"module"===e}function vt(e,t,n){const r=arguments.length;r<2?(n=e,t=[]):r<3&&(n=t,t="string"==typeof e?[]:e),nt.push(it.call(t,yt)?e=>{const r={},i={exports:r};return Promise.all(rt.call(t,(t=>"exports"===(t+="")?r:"module"===t?i:e(t)))).then((e=>(n.apply(null,e),i.exports)))}:e=>Promise.all(rt.call(t,e)).then((e=>"function"==typeof n?n.apply(null,e):n)))}vt.amd={};const bt="https://cdn.observableusercontent.com/npm/";let wt,gt=ht;async function _t(e){const[t,n]=await Promise.all([e(Fe.resolve()),e.resolve(Fe.resolve("dist/"))]);return t({locateFile:e=>`${n}${e}`})}class $t{constructor(e){Object.defineProperties(this,{_db:{value:e}})}static async open(e){const[t,n]=await Promise.all([_t(gt),Promise.resolve(e).then(At)]);return new $t(new t.Database(n))}async query(e,t){return await async function(e,t,n){const[r]=await e.exec(t,n);if(!r)return[];const{columns:i,values:o}=r,s=o.map((e=>Object.fromEntries(e.map(((e,t)=>[i[t],e])))));return s.columns=i,s}(this._db,e,t)}async queryRow(e,t){return(await this.query(e,t))[0]||null}async explain(e,t){return xt("pre",{className:"observablehq--inspect"},[St((await this.query(`EXPLAIN QUERY PLAN ${e}`,t)).map((e=>e.detail)).join("\n"))])}async describeTables({schema:e}={}){return this.query(`SELECT NULLIF(schema, 'main') AS schema, name FROM pragma_table_list() WHERE type = 'table'${null==e?"":" AND schema = ?"} AND name NOT LIKE 'sqlite_%' ORDER BY schema, name`,null==e?[]:[e])}async describeColumns({schema:e,table:t}={}){if(null==t)throw new Error("missing table");const n=await this.query(`SELECT name, type, "notnull" FROM pragma_table_info(?${null==e?"":", ?"}) ORDER BY cid`,null==e?[t]:[t,e]);if(!n.length)throw new Error(`table not found: ${t}`);return n.map((({name:e,type:t,notnull:n})=>({name:e,type:Et(t),databaseType:t,nullable:!n})))}async describe(e){const t=await(void 0===e?this.query("SELECT name FROM sqlite_master WHERE type = 'table'"):this.query("SELECT * FROM pragma_table_info(?)",[e]));if(!t.length)throw new Error("Not found");const{columns:n}=t;return xt("table",{value:t},[xt("thead",[xt("tr",n.map((e=>xt("th",[St(e)]))))]),xt("tbody",t.map((e=>xt("tr",n.map((t=>xt("td",[St(e[t])])))))))])}async sql(){return this.query(...this.queryTag.apply(this,arguments))}queryTag(e,...t){return[e.join("?"),t]}}function Et(e){switch(e){case"NULL":return"null";case"INT":case"INTEGER":case"TINYINT":case"SMALLINT":case"MEDIUMINT":case"BIGINT":case"UNSIGNED BIG INT":case"INT2":case"INT8":return"integer";case"TEXT":case"CLOB":case"DATE":case"DATETIME":return"string";case"REAL":case"DOUBLE":case"DOUBLE PRECISION":case"FLOAT":case"NUMERIC":return"number";case"BLOB":return"buffer";default:return/^(?:(?:(?:VARYING|NATIVE) )?CHARACTER|(?:N|VAR|NVAR)CHAR)\(/.test(e)?"string":/^(?:DECIMAL|NUMERIC)\(/.test(e)?"number":"other"}}function At(e){return"string"==typeof e?fetch(e).then(At):e instanceof Response||e instanceof Blob?e.arrayBuffer().then(At):e instanceof ArrayBuffer?new Uint8Array(e):e}function xt(e,t,n){2===arguments.length&&(n=t,t=void 0);const r=document.createElement(e);if(void 0!==t)for(const e in t)r[e]=t[e];if(void 0!==n)for(const e of n)r.appendChild(e);return r}function St(e){return document.createTextNode(e)}function kt(e,t){return null==e||null==t?NaN:e<t?-1:e>t?1:e>=t?0:NaN}function Ct(e,t=kt){let n,r=!1;if(1===t.length){let i;for(const o of e){const e=t(o);(r?kt(e,i)>0:0===kt(e,e))&&(n=o,i=e,r=!0)}}else for(const i of e)(r?t(i,n)>0:0===t(i,i))&&(n=i,r=!0);return n}function Tt(e){return e&&"function"==typeof e.toArrowBuffer}function Nt(e){return e&&"function"==typeof e.getChild&&"function"==typeof e.toArray&&e.schema&&Array.isArray(e.schema.fields)}function jt(e){return{name:e.name,type:Rt(e.type),nullable:e.nullable,databaseType:String(e.type)}}function Rt(e){switch(e.typeId){case 2:return"integer";case 3:case 7:return"number";case 4:case 15:return"buffer";case 5:return"string";case 6:return"boolean";case 8:case 9:case 10:return"date";case 12:case 16:return"array";case 13:case 14:return"object";default:return"other"}}async function Ot(){return await import(`${bt}${Je.resolve()}`)}Object.defineProperty($t.prototype,"dialect",{value:"sqlite"});class Pt{constructor(e){Object.defineProperties(this,{_db:{value:e}})}async queryStream(e,t){const n=await this._db.connect();let r,i;try{if(t?.length>0){const i=await n.prepare(e);r=await i.send(...t)}else r=await n.send(e);if(i=await r.next(),i.done)throw new Error("missing first batch")}catch(e){throw await n.close(),e}return{schema:(o=i.value,o.schema.fields.map(jt)),async*readRows(){try{for(;!i.done;)yield i.value.toArray(),i=await r.next()}finally{await n.close()}}};var o}async query(e,t){const n=await this.queryStream(e,t),r=[];for await(const e of n.readRows())for(const t of e)r.push(t);return r.schema=n.schema,r}async queryRow(e,t){const n=(await this.queryStream(e,t)).readRows();try{const{done:e,value:t}=await n.next();return e||!t.length?null:t[0]}finally{await n.return()}}async sql(e,...t){return await this.query(e.join("?"),t)}queryTag(e,...t){return[e.join("?"),t]}escape(e){return`"${e}"`}async describeTables(){return(await this.query("SHOW TABLES")).map((({name:e})=>({name:e})))}async describeColumns({table:e}={}){return(await this.query(`DESCRIBE ${this.escape(e)}`)).map((({column_name:e,column_type:t,null:n})=>({name:e,type:Dt(t),nullable:"NO"!==n,databaseType:t})))}static async of(e={},t={}){const n=await async function(){void 0===wt&&(wt=async function(){const e=await import(`${bt}${et.resolve()}`),t=await e.selectBundle({mvp:{mainModule:`${bt}${et.resolve("dist/duckdb-mvp.wasm")}`,mainWorker:`${bt}${et.resolve("dist/duckdb-browser-mvp.worker.js")}`},eh:{mainModule:`${bt}${et.resolve("dist/duckdb-eh.wasm")}`,mainWorker:`${bt}${et.resolve("dist/duckdb-browser-eh.worker.js")}`}}),n=new e.ConsoleLogger;return{module:e,bundle:t,logger:n}}());const{module:e,bundle:t,logger:n}=await wt,r=await e.createWorker(t.mainWorker),i=new e.AsyncDuckDB(n,r);return await i.instantiate(t.mainModule),i}();return void 0===t.query?.castTimestampToDate&&(t={...t,query:{...t.query,castTimestampToDate:!0}}),void 0===t.query?.castBigIntToDouble&&(t={...t,query:{...t.query,castBigIntToDouble:!0}}),await n.open(t),await Promise.all(Object.entries(e).map((async([e,t])=>{if(t instanceof On)await It(n,e,t);else if(Nt(t))await Mt(n,e,t);else if(Array.isArray(t))await Lt(n,e,t);else if(Tt(t))await async function(e,t,n){const r=(await Ot()).tableFromIPC(n.toArrowBuffer());return await Mt(e,t,r)}(n,e,t);else if("data"in t){const{data:r,...i}=t;Nt(r)?await Mt(n,e,r,i):await Lt(n,e,r,i)}else{if(!("file"in t))throw new Error(`invalid source: ${t}`);{const{file:r,...i}=t;await It(n,e,r,i)}}}))),new Pt(n)}}async function It(e,t,n,r){const i=await n.url();if(i.startsWith("blob:")){const t=await n.arrayBuffer();await e.registerFileBuffer(n.name,new Uint8Array(t))}else await e.registerFileURL(n.name,i,4);const o=await e.connect();try{switch(n.mimeType){case"text/csv":case"text/tab-separated-values":return await o.insertCSVFromPath(n.name,{name:t,schema:"main",...r}).catch((async e=>{if(e.toString().includes("Could not convert"))return await async function(e,t,n){const r=await e.prepare(`CREATE TABLE '${n}' AS SELECT * FROM read_csv_auto(?, ALL_VARCHAR=TRUE)`);return await r.send(t.name)}(o,n,t);throw e}));case"application/json":return await o.insertJSONFromPath(n.name,{name:t,schema:"main",...r});default:if(/\.arrow$/i.test(n.name)){const e=new Uint8Array(await n.arrayBuffer());return await o.insertArrowFromIPCStream(e,{name:t,schema:"main",...r})}if(/\.parquet$/i.test(n.name))return await o.query(`CREATE VIEW '${t}' AS SELECT * FROM parquet_scan('${n.name}')`);throw new Error(`unknown file type: ${n.mimeType}`)}}finally{await o.close()}}async function Mt(e,t,n,r){const i=await e.connect();try{await i.insertArrowTable(n,{name:t,schema:"main",...r})}finally{await i.close()}}async function Lt(e,t,n,r){const i=(await Ot()).tableFromJSON(n);return await Mt(e,t,i,r)}function Dt(e){switch(e){case"BIGINT":case"HUGEINT":case"UBIGINT":return"bigint";case"DOUBLE":case"REAL":case"FLOAT":return"number";case"INTEGER":case"SMALLINT":case"TINYINT":case"USMALLINT":case"UINTEGER":case"UTINYINT":return"integer";case"BOOLEAN":return"boolean";case"DATE":case"TIMESTAMP":case"TIMESTAMP WITH TIME ZONE":return"date";case"VARCHAR":case"UUID":return"string";default:return/^DECIMAL\(/.test(e)?"integer":"other"}}Object.defineProperty(Pt.prototype,"dialect",{value:"duckdb"});const qt=20;function Ut(e){return Array.isArray(e)&&(Bt(e.schema)||Ft(e.columns)||function(e){const t=Math.min(qt,e.length);for(let n=0;n<t;++n){const t=e[n];if(null===t||"object"!=typeof t)return!1}return t>0&&function(e){for(const t in e)return!0;return!1}(e[0])}(e)||Wt(e)||Gt(e))||Vt(e)}function Bt(e){return Array.isArray(e)&&e.every(Ht)}function Ft(e){return Array.isArray(e)&&e.every((e=>"string"==typeof e))}function Ht(e){return e&&"string"==typeof e.name&&"string"==typeof e.type}function zt(e){return Vt(e)||Wt(e)||Gt(e)}function Wt(e){const t=Math.min(qt,e.length);if(!(t>0))return!1;let n,r=!1;for(let i=0;i<t;++i){const t=e[i];if(null==t)continue;const o=typeof t;if(void 0===n)switch(o){case"number":case"boolean":case"string":case"bigint":n=o;break;default:return!1}else if(o!==n)return!1;r=!0}return r}function Gt(e){const t=Math.min(qt,e.length);if(!(t>0))return!1;let n=!1;for(let r=0;r<t;++r){const t=e[r];if(null!=t){if(!(t instanceof Date))return!1;n=!0}}return n}function Vt(e){return e instanceof Int8Array||e instanceof Int16Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray||e instanceof Uint16Array||e instanceof Uint32Array||e instanceof Float32Array||e instanceof Float64Array}const Jt=Object.assign((async(e,t,n,r)=>{if(e=await Zt(await e,r),(i=e)&&("function"==typeof i.sql||"function"==typeof i.queryTag&&("function"==typeof i.query||"function"==typeof i.queryStream))&&("table"!==o||"function"==typeof i.describeColumns)&&i!==Jt)return Qt(e,function(e,t){const n="function"==typeof t.escape?t.escape:e=>e,{select:r,from:i,filter:o,sort:s,slice:a}=e;if(!i.table)throw new Error("missing from table");if(r.columns&&0===r.columns.length)throw new Error("at least one column must be selected");const l=new Map(e.names?.map((({column:e,name:t})=>[e,t]))),c=r.columns?r.columns.map((e=>{const t=l.get(e);return t?`${n(e)} AS ${n(t)}`:n(e)})).join(", "):"*",u=[[`SELECT ${c} FROM ${en(i.table,n)}`]];for(let e=0;e<o.length;++e)tn(e?"\nAND ":"\nWHERE ",u),rn(o[e],u,n);for(let e=0;e<s.length;++e)tn(e?", ":"\nORDER BY ",u),nn(s[e],u,n);if("mssql"===t.dialect||"oracle"===t.dialect){if(null!==a.to||null!==a.from){if(!s.length){if(!r.columns)throw new Error("at least one column must be explicitly specified. Received '*'.");tn("\nORDER BY ",u),nn({column:r.columns[0],direction:"ASC"},u,n)}tn(`\nOFFSET ${a.from||0} ROWS`,u),tn(`\nFETCH NEXT ${null!==a.to?a.to-(a.from||0):1e9} ROWS ONLY`,u)}}else null===a.to&&null===a.from||tn("\nLIMIT "+(null!==a.to?a.to-(a.from||0):1e9),u),null!==a.from&&tn(` OFFSET ${a.from}`,u);return u}(t,e),n);var i,o;if(Ut(e))return function(e,t){const n=e;let{schema:r,columns:i}=e,o=!1;Bt(r)||(r=An(e,Ft(i)?i:void 0),o=!0);const s=new Map(r.map((({name:e,type:t})=>[e,t])));if(t.types){for(const{name:e,type:i}of t.types){s.set(e,i),r===n.schema&&(r=r.slice());const t=r.findIndex((t=>t.name===e));t>-1&&(r[t]={...r[t],type:i})}e=e.map((e=>$n(e,s,r)))}else o&&(e=e.map((e=>$n(e,s,r))));for(const{type:n,operands:r}of t.filter){const[{value:t}]=r,i=r.slice(1).map((({value:e})=>e));switch(n){case"v":{const[n]=i,r=wn(n);e=e.filter((e=>r(e[t])));break}case"nv":{const[n]=i,r=wn(n);e=e.filter((e=>!r(e[t])));break}case"eq":{const[n]=i;if(n instanceof Date){const r=+n;e=e.filter((e=>+e[t]===r))}else e=e.filter((e=>e[t]===n));break}case"ne":{const[n]=i;e=e.filter((e=>e[t]!==n));break}case"c":{const[n]=i;e=e.filter((e=>"string"==typeof e[t]&&e[t].includes(n)));break}case"nc":{const[n]=i;e=e.filter((e=>"string"==typeof e[t]&&!e[t].includes(n)));break}case"in":{const n=new Set(i);e=e.filter((e=>n.has(e[t])));break}case"nin":{const n=new Set(i);e=e.filter((e=>!n.has(e[t])));break}case"n":e=e.filter((e=>null==e[t]));break;case"nn":e=e.filter((e=>null!=e[t]));break;case"lt":{const[n]=i;e=e.filter((e=>e[t]<n));break}case"lte":{const[n]=i;e=e.filter((e=>e[t]<=n));break}case"gt":{const[n]=i;e=e.filter((e=>e[t]>n));break}case"gte":{const[n]=i;e=e.filter((e=>e[t]>=n));break}default:throw new Error(`unknown filter type: ${n}`)}}for(const{column:r,direction:i}of function(e){if("function"!=typeof e[Symbol.iterator])throw new TypeError("values is not iterable");return Array.from(e).reverse()}(t.sort)){const t="desc"===i?ln:an;e===n&&(e=e.slice()),e.sort(((e,n)=>t(e[r],n[r])))}let{from:a,to:l}=t.slice;a=null==a?0:Math.max(0,a),l=null==l?1/0:Math.max(0,l),(a>0||l<1/0)&&(e=e.slice(Math.max(0,a),Math.max(0,l)));if(t.select.columns){if(r){const e=new Map(r.map((e=>[e.name,e])));r=t.select.columns.map((t=>e.get(t)))}i&&(i=t.select.columns),e=e.map((e=>Object.fromEntries(t.select.columns.map((t=>[t,e[t]])))))}if(t.names){const n=new Map(t.names.map((e=>[e.column,e])));r&&(r=r.map((e=>{const t=n.get(e.name);return{...e,...t?{name:t.name}:null}}))),i&&(i=i.map((e=>{const t=n.get(e);return t?.name??e}))),e=e.map((e=>Object.fromEntries(Object.keys(e).map((t=>{const r=n.get(t);return[r?.name??t,e[t]]})))))}e!==n&&(r&&(e.schema=r),i&&(e.columns=i));return e}(e,t);if(!e)throw new Error("missing data source");throw new Error("invalid data source")}),{sql:(e,t,n)=>async function(){return Qt(await Kt(await e,n),arguments,t)}});function Yt(e){const t=new WeakMap;return(n,r)=>{if(!n)throw new Error("data source not found");let i=t.get(n);return(!i||Ut(n)&&n.length!==i._numRows)&&(i=e(n,r),i._numRows=n.length,t.set(n,i)),i}}const Zt=Yt((async(e,t)=>{if(e instanceof On){switch(e.mimeType){case"text/csv":return e.csv();case"text/tab-separated-values":return e.tsv();case"application/json":return e.json();case"application/x-sqlite3":return e.sqlite()}if(/\.(arrow|parquet)$/i.test(e.name))return Xt(e,t);throw new Error(`unsupported file type: ${e.mimeType}`)}return Nt(e)||Tt(e)?Xt(e,t):Ut(e)&&zt(e)?Array.from(e,(e=>({value:e}))):e})),Kt=Yt((async(e,t)=>{if(e instanceof On){switch(e.mimeType){case"text/csv":case"text/tab-separated-values":case"application/json":return Xt(e,t);case"application/x-sqlite3":return e.sqlite()}if(/\.(arrow|parquet)$/i.test(e.name))return Xt(e,t);throw new Error(`unsupported file type: ${e.mimeType}`)}return Ut(e)?Xt(await async function(e,t){const n=await Ot();return zt(e)?n.tableFromArrays({[t]:e}):n.tableFromJSON(e)}(e,t),t):Nt(e)||Tt(e)?Xt(e,t):e}));function Xt(e,t=(e instanceof On?function(e){return e.name.replace(/@\d+(?=\.|$)/,"").replace(/\.\w+$/,"")}(e):"__table")){return Pt.of({[t]:e})}async function Qt(e,t,n){if(!e)throw new Error("missing data source");if("function"==typeof e.queryTag){const r=new AbortController,i={signal:r.signal};if(n.then((()=>r.abort("invalidated"))),"function"==typeof e.queryStream)return async function*(e){let t=performance.now();const n=await e,r=[];r.done=!1,r.error=null,r.schema=n.schema;try{for await(const e of n.readRows()){performance.now()-t>150&&r.length>0&&(yield r,t=performance.now());for(const t of e)r.push(t)}r.done=!0,yield r}catch(e){r.error=e,yield r}}(e.queryStream(...e.queryTag.apply(e,t),i));if("function"==typeof e.query)return e.query(...e.queryTag.apply(e,t),i)}if("function"==typeof e.sql)return e.sql.apply(e,t);throw new Error("source does not implement query, queryStream, or sql")}function en(e,t){if("object"==typeof e){let n="";return null!=e.database&&(n+=t(e.database)+"."),null!=e.schema&&(n+=t(e.schema)+"."),n+=t(e.table),n}return t(e)}function tn(e,t){const n=t[0];n[n.length-1]+=e}function nn({column:e,direction:t},n,r){tn(`${r(e)} ${t.toUpperCase()}`,n)}function rn({type:e,operands:t},n,r){if(t.length<1)throw new Error("Invalid operand length");if(1===t.length||"v"===e||"nv"===e)switch(on(t[0],n,r),e){case"n":case"nv":return void tn(" IS NULL",n);case"nn":case"v":return void tn(" IS NOT NULL",n);default:throw new Error("Invalid filter operation")}if(2!==t.length||["in","nin"].includes(e)){var i;switch(on(t[0],n,r),e){case"in":tn(" IN (",n);break;case"nin":tn(" NOT IN (",n);break;default:throw new Error("Invalid filter operation")}!function(e,t){let n=!0;for(const r of e)n?n=!1:tn(",",t),t.push(r.value),t[0].push("")}(t.slice(1),n),tn(")",n)}else{if(["c","nc"].includes(e)){switch(on(t[0],n,r),e){case"c":tn(" LIKE ",n);break;case"nc":tn(" NOT LIKE ",n)}return void on((i=t[1],{...i,value:`%${i.value}%`}),n,r)}switch(on(t[0],n,r),e){case"eq":tn(" = ",n);break;case"ne":tn(" <> ",n);break;case"gt":tn(" > ",n);break;case"lt":tn(" < ",n);break;case"gte":tn(" >= ",n);break;case"lte":tn(" <= ",n);break;default:throw new Error("Invalid filter operation")}on(t[1],n,r)}}function on(e,t,n){"column"===e.type?tn(n(e.value),t):(t.push(e.value),t[0].push(""))}function sn(e,t){return(null==e||!(e>=e))-(null==t||!(t>=t))}function an(e,t){return sn(e,t)||(e<t?-1:e>t?1:0)}function ln(e,t){return sn(e,t)||(e>t?-1:e<t?1:0)}const cn=e=>"number"==typeof e&&!Number.isNaN(e),un=e=>Number.isInteger(e)&&!Number.isNaN(e),dn=e=>"string"==typeof e,hn=e=>"boolean"==typeof e,fn=e=>"bigint"==typeof e,pn=e=>e instanceof Date&&!isNaN(e),mn=e=>e instanceof ArrayBuffer,yn=e=>Array.isArray(e),vn=e=>"object"==typeof e&&null!==e,bn=e=>null!=e;function wn(e){switch(e){case"string":return dn;case"bigint":return fn;case"boolean":return hn;case"number":return cn;case"integer":return un;case"date":return pn;case"buffer":return mn;case"array":return yn;case"object":return vn;default:return bn}}const gn=/^(([-+]\d{2})?\d{4}(-\d{2}(-\d{2}))|(\d{1,2})\/(\d{1,2})\/(\d{2,4}))([T ]\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/;function _n(e,t){switch(t){case"string":return"string"==typeof e||null==e?e:String(e);case"boolean":if("string"==typeof e){const t=e.trim().toLowerCase();return"true"===t||"false"!==t&&null}return"boolean"==typeof e||null==e?e:Boolean(e);case"bigint":return"bigint"==typeof e||null==e?e:Number.isInteger("string"!=typeof e||e.trim()?+e:NaN)?BigInt(e):void 0;case"integer":case"number":return"number"==typeof e?e:null==e||"string"==typeof e&&!e.trim()?NaN:Number(e);case"date":{if(e instanceof Date||null==e)return e;if("number"==typeof e)return new Date(e);const t=String(e).trim();return"string"!=typeof e||t?new Date(gn.test(t)?t:NaN):null}case"array":case"object":case"buffer":case"other":return e;default:throw new Error(`Unable to coerce to type: ${t}`)}}function $n(e,t,n){const r={};for(const i of n){const n=t.get(i.name),o=e[i.name];r[i.name]="raw"===n?o:_n(o,n)}return r}const En=["boolean","integer","number","date","bigint","array","object","buffer"];function An(e,t=function(e){const t=new Set;for(const n of e)if(n)for(const e in n)Object.prototype.hasOwnProperty.call(n,e)&&t.add(e);return Array.from(t)}(e)){const n=[],r=e.slice(0,100);for(const e of t){const t={boolean:0,integer:0,number:0,date:0,string:0,array:0,object:0,bigint:0,buffer:0,defined:0};for(const n of r){let r=n[e];if(null==r)continue;const i=typeof r;if("string"!==i)++t.defined,Array.isArray(r)?++t.array:r instanceof Date?++t.date:r instanceof ArrayBuffer?++t.buffer:"number"===i?(++t.number,Number.isInteger(r)&&++t.integer):i in t&&++t[i];else{if(r=r.trim(),!r)continue;++t.defined,++t.string,/^(true|false)$/i.test(r)?++t.boolean:r&&!isNaN(r)?(++t.number,Number.isInteger(+r)&&++t.integer):gn.test(r)&&++t.date}}const i=Math.max(1,.9*t.defined),o=Ct(En,(e=>t[e]>=i?t[e]:NaN))??(t.string>=i?"string":"other");n.push({name:e,type:o,inferred:o})}return n}class xn{constructor(e){Object.defineProperties(this,{_:{value:e},sheetNames:{value:e.worksheets.map((e=>e.name)),enumerable:!0}})}sheet(e,t){const n="number"==typeof e?this.sheetNames[e]:this.sheetNames.includes(e+="")?e:null;if(null==n)throw new Error(`Sheet not found: ${e}`);return function(e,{range:t,headers:n}={}){let[[r,i],[o,s]]=function(e=":",{columnCount:t,rowCount:n}){if(!(e+="").match(/^[A-Z]*\d*:[A-Z]*\d*$/))throw new Error("Malformed range specifier");const[[r=0,i=0],[o=t-1,s=n-1]]=e.split(":").map(Tn);return[[r,i],[o,s]]}(t,e);const a=n?e._rows[i++]:null;let l=new Set(["#"]);for(let e=r;e<=o;e++){const t=a?Sn(a.findCell(e+1)):null;let n=t&&t+""||Cn(e);for(;l.has(n);)n+="_";l.add(n)}l=new Array(r).concat(Array.from(l));const c=new Array(s-i+1);for(let t=i;t<=s;t++){const n=c[t-i]=Object.create(null,{"#":{value:t+1}}),s=e.getRow(t+1);if(s.hasValues)for(let e=r;e<=o;e++){const t=Sn(s.findCell(e+1));null!=t&&(n[l[e+1]]=t)}}return c.columns=l.filter((()=>!0)),c}(this._.getWorksheet(n),t)}}function Sn(e){if(!e)return;const{value:t}=e;if(t&&"object"==typeof t&&!(t instanceof Date)){if(t.formula||t.sharedFormula)return t.result&&t.result.error?NaN:t.result;if(t.richText)return kn(t);if(t.text){let{text:e}=t;return e.richText&&(e=kn(e)),t.hyperlink&&t.hyperlink!==e?`${t.hyperlink} ${e}`:e}return t}return t}function kn(e){return e.richText.map((e=>e.text)).join("")}function Cn(e){let t="";e++;do{t=String.fromCharCode(64+(e%26||26))+t}while(e=Math.floor((e-1)/26));return t}function Tn(e){const[,t,n]=e.match(/^([A-Z]*)(\d*)$/);let r=0;if(t)for(let e=0;e<t.length;e++)r+=Math.pow(26,t.length-e-1)*(t.charCodeAt(e)-64);return[r?r-1:void 0,n?+n-1:void 0]}async function Nn(e){const t=await fetch(await e.url());if(!t.ok)throw new Error(`Unable to load file: ${e.name}`);return t}async function jn(e,t,{array:n=!1,typed:r=!1}={}){const i=await e.text(),o="\t"===t?n?Ce:ke:n?xe:Ae;if("auto"===r&&!n){const e=o(i);return function(e,t){const n=new Map(t.map((({name:e,type:t})=>[e,t])));return Object.assign(e.map((e=>$n(e,n,t))),{schema:t})}(e,An(e,e.columns))}return o(i,r&&Te)}class Rn{constructor(e,t){Object.defineProperty(this,"name",{value:e,enumerable:!0}),void 0!==t&&Object.defineProperty(this,"mimeType",{value:t+"",enumerable:!0})}async blob(){return(await Nn(this)).blob()}async arrayBuffer(){return(await Nn(this)).arrayBuffer()}async text(){return(await Nn(this)).text()}async json(){return(await Nn(this)).json()}async stream(){return(await Nn(this)).body}async csv(e){return jn(this,",",e)}async tsv(e){return jn(this,"\t",e)}async image(e){const t=await this.url();return new Promise(((n,r)=>{const i=new Image;new URL(t,document.baseURI).origin!==new URL(location).origin&&(i.crossOrigin="anonymous"),Object.assign(i,e),i.onload=()=>n(i),i.onerror=()=>r(new Error(`Unable to load file: ${this.name}`)),i.src=t}))}async arrow({version:e=4}={}){switch(e){case 4:{const[e,t]=await Promise.all([gt(Ge.resolve()),Nn(this)]);return e.Table.from(t)}case 9:{const[e,t]=await Promise.all([import(`${bt}${Ve.resolve()}`),Nn(this)]);return e.tableFromIPC(t)}case 11:{const[e,t]=await Promise.all([import(`${bt}${Je.resolve()}`),Nn(this)]);return e.tableFromIPC(t)}default:throw new Error(`unsupported arrow version: ${e}`)}}async sqlite(){return $t.open(Nn(this))}async zip(){const[e,t]=await Promise.all([gt(Ue.resolve()),this.arrayBuffer()]);return new In(await e.loadAsync(t))}async xml(e="application/xml"){return(new DOMParser).parseFromString(await this.text(),e)}async html(){return this.xml("text/html")}async xlsx(){const[e,t]=await Promise.all([gt(Ke.resolve()),this.arrayBuffer()]);return new xn(await(new e.Workbook).xlsx.load(t))}}class On extends Rn{constructor(e,t,n){super(t,n),Object.defineProperty(this,"_url",{value:e})}async url(){return await this._url+""}}function Pn(e){throw new Error(`File not found: ${e}`)}class In{constructor(e){Object.defineProperty(this,"_",{value:e}),this.filenames=Object.keys(e.files).filter((t=>!e.files[t].dir))}file(e){const t=this._.file(e+="");if(!t||t.dir)throw new Error(`file not found: ${e}`);return new Mn(t)}}class Mn extends Rn{constructor(e){super(e.name),Object.defineProperty(this,"_",{value:e}),Object.defineProperty(this,"_url",{writable:!0})}async url(){return this._url||(this._url=this.blob().then(URL.createObjectURL))}async blob(){return this._.async("blob")}async arrayBuffer(){return this._.async("arraybuffer")}async text(){return this._.async("text")}async json(){return JSON.parse(await this.text())}}var Ln={math:"http://www.w3.org/1998/Math/MathML",svg:"http://www.w3.org/2000/svg",xhtml:"http://www.w3.org/1999/xhtml",xlink:"http://www.w3.org/1999/xlink",xml:"http://www.w3.org/XML/1998/namespace",xmlns:"http://www.w3.org/2000/xmlns/"};var Dn=0;function qn(e){return new Un("O-"+(null==e?"":e+"-")+ ++Dn)}function Un(e){this.id=e,this.href=new URL(`#${e}`,location)+""}Un.prototype.toString=function(){return"url("+this.href+")"};var Bn=Object.freeze({__proto__:null,canvas:function(e,t){var n=document.createElement("canvas");return n.width=e,n.height=t,n},context2d:function(e,t,n){null==n&&(n=devicePixelRatio);var r=document.createElement("canvas");r.width=e*n,r.height=t*n,r.style.width=e+"px";var i=r.getContext("2d");return i.scale(n,n),i},download:function(e,t="untitled",n="Save"){const r=document.createElement("a"),i=r.appendChild(document.createElement("button"));async function o(){await new Promise(requestAnimationFrame),URL.revokeObjectURL(r.href),r.removeAttribute("href"),i.textContent=n,i.disabled=!1}return i.textContent=n,r.download=t,r.onclick=async t=>{if(i.disabled=!0,r.href)return o();i.textContent="Saving…";try{const t=await("function"==typeof e?e():e);i.textContent="Download",r.href=URL.createObjectURL(t)}catch(e){i.textContent=n}if(t.eventPhase)return o();i.disabled=!1},r},element:function(e,t){var n,r=e+="",i=r.indexOf(":");i>=0&&"xmlns"!==(r=e.slice(0,i))&&(e=e.slice(i+1));var o=Ln.hasOwnProperty(r)?document.createElementNS(Ln[r],e):document.createElement(e);if(t)for(var s in t)i=(r=s).indexOf(":"),n=t[s],i>=0&&"xmlns"!==(r=s.slice(0,i))&&(s=s.slice(i+1)),Ln.hasOwnProperty(r)?o.setAttributeNS(Ln[r],s,n):o.setAttribute(s,n);return o},input:function(e){var t=document.createElement("input");return null!=e&&(t.type=e),t},range:function(e,t,n){1===arguments.length&&(t=e,e=null);var r=document.createElement("input");return r.min=e=null==e?0:+e,r.max=t=null==t?1:+t,r.step=null==n?"any":n=+n,r.type="range",r},select:function(e){var t=document.createElement("select");return Array.prototype.forEach.call(e,(function(e){var n=document.createElement("option");n.value=n.textContent=e,t.appendChild(n)})),t},svg:function(e,t){var n=document.createElementNS("http://www.w3.org/2000/svg","svg");return n.setAttribute("viewBox",[0,0,e,t]),n.setAttribute("width",e),n.setAttribute("height",t),n},text:function(e){return document.createTextNode(e)},uid:qn});var Fn=Object.freeze({__proto__:null,buffer:function(e){return new Promise((function(t,n){var r=new FileReader;r.onload=function(){t(r.result)},r.onerror=n,r.readAsArrayBuffer(e)}))},text:function(e){return new Promise((function(t,n){var r=new FileReader;r.onload=function(){t(r.result)},r.onerror=n,r.readAsText(e)}))},url:function(e){return new Promise((function(t,n){var r=new FileReader;r.onload=function(){t(r.result)},r.onerror=n,r.readAsDataURL(e)}))}});function Hn(){return this}function zn(e,t){let n=!1;if("function"!=typeof t)throw new Error("dispose is not a function");return{[Symbol.iterator]:Hn,next:()=>n?{done:!0}:(n=!0,{done:!1,value:e}),return:()=>(n=!0,t(e),{done:!0}),throw:()=>({done:n=!0})}}function Wn(e){let t,n,r=!1;const i=e((function(e){n?(n(e),n=null):r=!0;return t=e}));if(null!=i&&"function"!=typeof i)throw new Error("function"==typeof i.then?"async initializers are not supported":"initializer returned something, but not a dispose function");return{[Symbol.iterator]:Hn,throw:()=>({done:!0}),return:()=>(null!=i&&i(),{done:!0}),next:function(){return{done:!1,value:r?(r=!1,Promise.resolve(t)):new Promise((e=>n=e))}}}}function Gn(e){switch(e.type){case"range":case"number":return e.valueAsNumber;case"date":return e.valueAsDate;case"checkbox":return e.checked;case"file":return e.multiple?e.files:e.files[0];case"select-multiple":return Array.from(e.selectedOptions,(e=>e.value));default:return e.value}}var Vn=Object.freeze({__proto__:null,disposable:zn,filter:function*(e,t){for(var n,r=-1;!(n=e.next()).done;)t(n.value,++r)&&(yield n.value)},input:function(e){return Wn((function(t){var n=function(e){switch(e.type){case"button":case"submit":case"checkbox":return"click";case"file":return"change";default:return"input"}}(e),r=Gn(e);function i(){t(Gn(e))}return e.addEventListener(n,i),void 0!==r&&t(r),function(){e.removeEventListener(n,i)}}))},map:function*(e,t){for(var n,r=-1;!(n=e.next()).done;)yield t(n.value,++r)},observe:Wn,queue:function(e){let t;const n=[],r=e((function(e){n.push(e),t&&(t(n.shift()),t=null);return e}));if(null!=r&&"function"!=typeof r)throw new Error("function"==typeof r.then?"async initializers are not supported":"initializer returned something, but not a dispose function");return{[Symbol.iterator]:Hn,throw:()=>({done:!0}),return:()=>(null!=r&&r(),{done:!0}),next:function(){return{done:!1,value:n.length?Promise.resolve(n.shift()):new Promise((e=>t=e))}}}},range:function*(e,t,n){e=+e,t=+t,n=(i=arguments.length)<2?(t=e,e=0,1):i<3?1:+n;for(var r=-1,i=0|Math.max(0,Math.ceil((t-e)/n));++r<i;)yield e+r*n},valueAt:function(e,t){if(!(!isFinite(t=+t)||t<0||t!=t|0))for(var n,r=-1;!(n=e.next()).done;)if(++r===t)return n.value},worker:function(e){const t=URL.createObjectURL(new Blob([e],{type:"text/javascript"})),n=new Worker(t);return zn(n,(()=>{n.terminate(),URL.revokeObjectURL(t)}))}});function Jn(e,t){return function(n){var r,i,o,s,a,l,c,u,d=n[0],h=[],f=null,p=-1;for(a=1,l=arguments.length;a<l;++a){if((r=arguments[a])instanceof Node)h[++p]=r,d+="\x3c!--o:"+p+"--\x3e";else if(Array.isArray(r)){for(c=0,u=r.length;c<u;++c)(i=r[c])instanceof Node?(null===f&&(h[++p]=f=document.createDocumentFragment(),d+="\x3c!--o:"+p+"--\x3e"),f.appendChild(i)):(f=null,d+=i);f=null}else d+=r;d+=n[a]}if(f=e(d),++p>0){for(o=new Array(p),s=document.createTreeWalker(f,NodeFilter.SHOW_COMMENT,null,!1);s.nextNode();)i=s.currentNode,/^o:/.test(i.nodeValue)&&(o[+i.nodeValue.slice(2)]=i);for(a=0;a<p;++a)(i=o[a])&&i.parentNode.replaceChild(h[a],i)}return 1===f.childNodes.length?f.removeChild(f.firstChild):11===f.nodeType?((i=t()).appendChild(f),i):f}}const Yn=Jn((function(e){var t=document.createElement("template");return t.innerHTML=e.trim(),document.importNode(t.content,!0)}),(function(){return document.createElement("span")}));function Zn(e){let t;Object.defineProperties(this,{generator:{value:Wn((e=>{t=e}))},value:{get:()=>e,set:n=>t(e=n)}}),void 0!==e&&t(e)}function*Kn(){for(;;)yield Date.now()}var Xn=new Map;function Qn(e,t){var n;return(n=Xn.get(e=+e))?n.then((()=>t)):(n=Date.now())>=e?Promise.resolve(t):function(e,t){var n=new Promise((function(n){Xn.delete(t);var r=t-e;if(!(r>0))throw new Error("invalid time");if(r>2147483647)throw new Error("too long to wait");setTimeout(n,r)}));return Xn.set(t,n),n}(n,e).then((()=>t))}var er=Object.freeze({__proto__:null,delay:function(e,t){return new Promise((function(n){setTimeout((function(){n(t)}),e)}))},tick:function(e,t){return Qn(Math.ceil((Date.now()+1)/e)*e,t)},when:Qn});function tr(e,t){if(/^(\w+:)|\/\//i.test(e))return e;if(/^[.]{0,2}\//i.test(e))return new URL(e,t??location).href;if(!e.length||/^[\s._]/.test(e)||/\s$/.test(e))throw new Error("illegal name");return"https://unpkg.com/"+e}const nr=Jn((function(e){var t=document.createElementNS("http://www.w3.org/2000/svg","g");return t.innerHTML=e.trim(),t}),(function(){return document.createElementNS("http://www.w3.org/2000/svg","g")}));var rr=String.raw;function ir(e){return new Promise((function(t,n){var r=document.createElement("link");r.rel="stylesheet",r.href=e,r.onerror=n,r.onload=t,document.head.appendChild(r)}))}function or(){return Wn((function(e){var t=e(document.body.clientWidth);function n(){var n=document.body.clientWidth;n!==t&&e(t=n)}return window.addEventListener("resize",n),function(){window.removeEventListener("resize",n)}}))}const sr=Object.assign(Object.defineProperties((function(e){const t=function(e){return null==e?gt:ft(e)}(e);var n;Object.defineProperties(this,(n={FileAttachment:()=>Pn,Mutable:()=>Zn,now:Kn,width:or,dot:()=>t(Ie.resolve()),htl:()=>t(qe.resolve()),html:()=>Yn,md:()=>function(e){return e(Be.resolve()).then((function(t){return Jn((function(n){var r=document.createElement("div");r.innerHTML=t(n,{langPrefix:""}).trim();var i=r.querySelectorAll("pre code[class]");return i.length>0&&e(Me.resolve()).then((function(t){i.forEach((function(n){function r(){t.highlightBlock(n),n.parentNode.classList.add("observablehq--md-pre")}t.getLanguage(n.className)?r():e(Me.resolve("async-languages/index.js")).then((r=>{if(r.has(n.className))return e(Me.resolve("async-languages/"+r.get(n.className))).then((e=>{t.registerLanguage(n.className,e)}))})).then(r,r)}))})),r}),(function(){return document.createElement("div")}))}))}(t),svg:()=>nr,tex:()=>function(e){return Promise.all([e(Le.resolve()),e.resolve(Le.resolve("dist/katex.min.css")).then(ir)]).then((function(e){var t=e[0],n=r();function r(e){return function(){var n=document.createElement("div");return t.render(rr.apply(String,arguments),n,e),n.removeChild(n.firstChild)}}return n.options=r,n.block=r({displayMode:!0}),n}))}(t),_:()=>t(De.resolve()),aq:()=>t.alias({"apache-arrow":Ge.resolve()})(Ye.resolve()),Arrow:()=>t(Ge.resolve()),d3:()=>t(Re.resolve()),DuckDBClient:()=>Pt,Inputs:()=>t(Oe.resolve()).then((e=>({...e,file:e.fileOf(Rn)}))),L:()=>async function(e){const t=await e(Qe.resolve());if(!t._style){const n=document.createElement("link");n.rel="stylesheet",n.href=await e.resolve(Qe.resolve("dist/leaflet.css")),t._style=document.head.appendChild(n)}return t}(t),mermaid:()=>async function(e){const t=await e(Xe.resolve());return t.initialize({securityLevel:"loose",theme:"neutral"}),function(){const e=document.createElement("div");return e.innerHTML=t.render(qn().id,String.raw.apply(String,arguments)),e.removeChild(e.firstChild)}}(t),Plot:()=>t(Pe.resolve()),__query:()=>Jt,require:()=>t,resolve:()=>tr,SQLite:()=>_t(t),SQLiteDatabaseClient:()=>$t,topojson:()=>t(Ze.resolve()),vl:()=>async function(e){const[t,n,r]=await Promise.all([He,ze,We].map((t=>e(t.resolve()))));return r.register(t,n)}(t),aapl:()=>new On("https://static.observableusercontent.com/files/3ccff97fd2d93da734e76829b2b066eafdaac6a1fafdec0faf6ebc443271cfc109d29e80dd217468fcb2aff1e6bffdc73f356cc48feb657f35378e6abbbb63b9").csv({typed:!0}),alphabet:()=>new On("https://static.observableusercontent.com/files/75d52e6c3130b1cae83cda89305e17b50f33e7420ef205587a135e8562bcfd22e483cf4fa2fb5df6dff66f9c5d19740be1cfaf47406286e2eb6574b49ffc685d").csv({typed:!0}),cars:()=>new On("https://static.observableusercontent.com/files/048ec3dfd528110c0665dfa363dd28bc516ffb7247231f3ab25005036717f5c4c232a5efc7bb74bc03037155cb72b1abe85a33d86eb9f1a336196030443be4f6").csv({typed:!0}),citywages:()=>new On("https://static.observableusercontent.com/files/39837ec5121fcc163131dbc2fe8c1a2e0b3423a5d1e96b5ce371e2ac2e20a290d78b71a4fb08b9fa6a0107776e17fb78af313b8ea70f4cc6648fad68ddf06f7a").csv({typed:!0}),diamonds:()=>new On("https://static.observableusercontent.com/files/87942b1f5d061a21fa4bb8f2162db44e3ef0f7391301f867ab5ba718b225a63091af20675f0bfe7f922db097b217b377135203a7eab34651e21a8d09f4e37252").csv({typed:!0}),flare:()=>new On("https://static.observableusercontent.com/files/a6b0d94a7f5828fd133765a934f4c9746d2010e2f342d335923991f31b14120de96b5cb4f160d509d8dc627f0107d7f5b5070d2516f01e4c862b5b4867533000").csv({typed:!0}),industries:()=>new On("https://static.observableusercontent.com/files/76f13741128340cc88798c0a0b7fa5a2df8370f57554000774ab8ee9ae785ffa2903010cad670d4939af3e9c17e5e18e7e05ed2b38b848ac2fc1a0066aa0005f").csv({typed:!0}),miserables:()=>new On("https://static.observableusercontent.com/files/31d904f6e21d42d4963ece9c8cc4fbd75efcbdc404bf511bc79906f0a1be68b5a01e935f65123670ed04e35ca8cae3c2b943f82bf8db49c5a67c85cbb58db052").json(),olympians:()=>new On("https://static.observableusercontent.com/files/31ca24545a0603dce099d10ee89ee5ae72d29fa55e8fc7c9ffb5ded87ac83060d80f1d9e21f4ae8eb04c1e8940b7287d179fe8060d887fb1f055f430e210007c").csv({typed:!0}),penguins:()=>new On("https://static.observableusercontent.com/files/715db1223e067f00500780077febc6cebbdd90c151d3d78317c802732252052ab0e367039872ab9c77d6ef99e5f55a0724b35ddc898a1c99cb14c31a379af80a").csv({typed:!0}),weather:()=>new On("https://static.observableusercontent.com/files/693a46b22b33db0f042728700e0c73e836fa13d55446df89120682d55339c6db7cc9e574d3d73f24ecc9bc7eb9ac9a1e7e104a1ee52c00aab1e77eb102913c1f").csv({typed:!0}),DOM:Bn,Files:Fn,Generators:Vn,Promises:er},Object.fromEntries(Object.entries(n).map(ar))))}),{resolve:{get:()=>gt.resolve,enumerable:!0,configurable:!0},require:{get:()=>gt,set:function(e){gt=e},enumerable:!0,configurable:!0}}),{resolveFrom:dt,requireFrom:ft});function ar([e,t]){return[e,{value:t,writable:!0,enumerable:!0}]}class lr extends Error{constructor(e,t){super(e),this.input=t}}function cr(e){return()=>e}function ur(e){return e}lr.prototype.name="RuntimeError";const dr=Array.prototype.map;function hr(){}const fr=1,pr=2,mr=3,yr=Symbol("no-observer");function vr(e,t,n){var r;n||(n=yr),Object.defineProperties(this,{_observer:{value:n,writable:!0},_definition:{value:gr,writable:!0},_duplicate:{value:void 0,writable:!0},_duplicates:{value:void 0,writable:!0},_indegree:{value:NaN,writable:!0},_inputs:{value:[],writable:!0},_invalidate:{value:hr,writable:!0},_module:{value:t},_name:{value:null,writable:!0},_outputs:{value:new Set,writable:!0},_promise:{value:Promise.resolve(void 0),writable:!0},_reachable:{value:n!==yr,writable:!0},_rejector:{value:(r=this,e=>{if(e===_r)throw e;if(e===gr)throw new lr(`${r._name} is not defined`,r._name);if(e instanceof Error&&e.message)throw new lr(e.message,r._name);throw new lr(`${r._name} could not be resolved`,r._name)})},_type:{value:e},_value:{value:void 0,writable:!0},_version:{value:0,writable:!0}})}function br(e){e._module._runtime._dirty.add(e),e._outputs.add(this)}function wr(e){e._module._runtime._dirty.add(e),e._outputs.delete(this)}function gr(){throw gr}function _r(){throw _r}function $r(e){return()=>{throw new lr(`${e} is defined more than once`)}}function Er(e,t,n){const r=this._module._scope,i=this._module._runtime;if(this._inputs.forEach(wr,this),t.forEach(br,this),this._inputs=t,this._definition=n,this._value=void 0,n===hr?i._variables.delete(this):i._variables.add(this),e!==this._name||r.get(e)!==this){let t,o;if(this._name)if(this._outputs.size)r.delete(this._name),o=this._module._resolve(this._name),o._outputs=this._outputs,this._outputs=new Set,o._outputs.forEach((function(e){e._inputs[e._inputs.indexOf(this)]=o}),this),o._outputs.forEach(i._updates.add,i._updates),i._dirty.add(o).add(this),r.set(this._name,o);else if((o=r.get(this._name))===this)r.delete(this._name);else{if(o._type!==mr)throw new Error;o._duplicates.delete(this),this._duplicate=void 0,1===o._duplicates.size&&(o=o._duplicates.keys().next().value,t=r.get(this._name),o._outputs=t._outputs,t._outputs=new Set,o._outputs.forEach((function(e){e._inputs[e._inputs.indexOf(t)]=o})),o._definition=o._duplicate,o._duplicate=void 0,i._dirty.add(t).add(o),i._updates.add(o),r.set(this._name,o))}if(this._outputs.size)throw new Error;e&&((o=r.get(e))?o._type===mr?(this._definition=$r(e),this._duplicate=n,o._duplicates.add(this)):o._type===pr?(this._outputs=o._outputs,o._outputs=new Set,this._outputs.forEach((function(e){e._inputs[e._inputs.indexOf(o)]=this}),this),i._dirty.add(o).add(this),r.set(e,this)):(o._duplicate=o._definition,this._duplicate=n,t=new vr(mr,this._module),t._name=e,t._definition=this._definition=o._definition=$r(e),t._outputs=o._outputs,o._outputs=new Set,t._outputs.forEach((function(e){e._inputs[e._inputs.indexOf(o)]=t})),t._duplicates=new Set([this,o]),i._dirty.add(o).add(t),i._updates.add(o).add(t),r.set(e,t)):r.set(e,this)),this._name=e}return this._version>0&&++this._version,i._updates.add(this),i._compute(),this}Object.defineProperties(vr.prototype,{_pending:{value:function(){this._observer.pending&&this._observer.pending()},writable:!0,configurable:!0},_fulfilled:{value:function(e){this._observer.fulfilled&&this._observer.fulfilled(e,this._name)},writable:!0,configurable:!0},_rejected:{value:function(e){this._observer.rejected&&this._observer.rejected(e,this._name)},writable:!0,configurable:!0},define:{value:function(e,t,n){switch(arguments.length){case 1:n=e,e=t=null;break;case 2:n=t,"string"==typeof e?t=null:(t=e,e=null)}return Er.call(this,null==e?null:String(e),null==t?[]:dr.call(t,this._module._resolve,this._module),"function"==typeof n?n:cr(n))},writable:!0,configurable:!0},delete:{value:function(){return Er.call(this,null,[],hr)},writable:!0,configurable:!0},import:{value:function(e,t,n){arguments.length<3&&(n=t,t=e);return Er.call(this,String(t),[n._resolve(String(e))],ur)},writable:!0,configurable:!0}});const Ar=Symbol("variable"),xr=Symbol("invalidation"),Sr=Symbol("visibility");function kr(e,t=[]){Object.defineProperties(this,{_runtime:{value:e},_scope:{value:new Map},_builtins:{value:new Map([["@variable",Ar],["invalidation",xr],["visibility",Sr],...t])},_source:{value:null,writable:!0}})}async function Cr(e,t){await e._compute();try{return await t._promise}catch(n){if(n===_r)return Cr(e,t);throw n}}function Tr(e){return e._name}Object.defineProperties(kr.prototype,{_resolve:{value:function(e){let t,n=this._scope.get(e);if(!n)if(n=new vr(pr,this),this._builtins.has(e))n.define(e,cr(this._builtins.get(e)));else if(this._runtime._builtin._scope.has(e))n.import(e,this._runtime._builtin);else{try{t=this._runtime._global(e)}catch(t){return n.define(e,function(e){return()=>{throw e}}(t))}void 0===t?this._scope.set(n._name=e,n):n.define(e,cr(t))}return n},writable:!0,configurable:!0},redefine:{value:function(e){const t=this._scope.get(e);if(!t)throw new lr(`${e} is not defined`);if(t._type===mr)throw new lr(`${e} is defined more than once`);return t.define.apply(t,arguments)},writable:!0,configurable:!0},define:{value:function(){const e=new vr(fr,this);return e.define.apply(e,arguments)},writable:!0,configurable:!0},derive:{value:function(e,t){const n=new Map,r=new Set,i=[];function o(e){let t=n.get(e);return t||(t=new kr(e._runtime,e._builtins),t._source=e,n.set(e,t),i.push([t,e]),r.add(e),t)}const s=o(this);for(const n of e){const{alias:e,name:r}="object"==typeof n?n:{name:n};s.import(r,e??r,t)}for(const e of r)for(const[t,n]of e._scope)if(n._definition===ur){if(e===this&&s._scope.has(t))continue;const r=n._inputs[0]._module;r._source&&o(r)}for(const[e,t]of i)for(const[r,i]of t._scope){const t=e._scope.get(r);if(!t||t._type===pr)if(i._definition===ur){const t=i._inputs[0],o=t._module;e.import(t._name,r,n.get(o)||o)}else e.define(r,i._inputs.map(Tr),i._definition)}return s},writable:!0,configurable:!0},import:{value:function(){const e=new vr(fr,this);return e.import.apply(e,arguments)},writable:!0,configurable:!0},value:{value:async function(e){let t=this._scope.get(e);if(!t)throw new lr(`${e} is not defined`);if(t._observer!==yr)return Cr(this._runtime,t);t=this.variable(!0).define([e],ur);try{return await Cr(this._runtime,t)}finally{t.delete()}},writable:!0,configurable:!0},variable:{value:function(e){return new vr(fr,this,e)},writable:!0,configurable:!0},builtin:{value:function(e,t){this._builtins.set(e,t)},writable:!0,configurable:!0}});const Nr="function"==typeof requestAnimationFrame?requestAnimationFrame:"function"==typeof setImmediate?setImmediate:e=>setTimeout(e,0);function jr(e=new sr,t=Ur){const n=this.module();if(Object.defineProperties(this,{_dirty:{value:new Set},_updates:{value:new Set},_precomputes:{value:[],writable:!0},_computing:{value:null,writable:!0},_init:{value:null,writable:!0},_modules:{value:new Map},_variables:{value:new Set},_disposed:{value:!1,writable:!0},_builtin:{value:n},_global:{value:t}}),e)for(const t in e)new vr(pr,n).define(t,[],e[t])}function Rr(e){const t=new Set(e._inputs);for(const n of t){if(n===e)return!0;n._inputs.forEach(t.add,t)}return!1}function Or(e){++e._indegree}function Pr(e){--e._indegree}function Ir(e){return e._promise.catch(e._rejector)}function Mr(e){return new Promise((function(t){e._invalidate=t}))}function Lr(e,t){let n,r,i="function"==typeof IntersectionObserver&&t._observer&&t._observer._node,o=!i,s=hr,a=hr;return i&&(r=new IntersectionObserver((([e])=>(o=e.isIntersecting)&&(n=null,s()))),r.observe(i),e.then((()=>(r.disconnect(),r=null,a())))),function(e){return o?Promise.resolve(e):r?(n||(n=new Promise(((e,t)=>(s=e,a=t)))),n.then((()=>e))):Promise.reject()}}function Dr(e){e._invalidate(),e._invalidate=hr,e._pending();const t=e._value,n=++e._version;let r=null;const i=e._promise=(e._inputs.length?Promise.all(e._inputs.map(Ir)).then((function(i){if(e._version!==n)throw _r;for(let t=0,n=i.length;t<n;++t)switch(i[t]){case xr:i[t]=r=Mr(e);break;case Sr:r||(r=Mr(e)),i[t]=Lr(r,e);break;case Ar:i[t]=e}return e._definition.apply(t,i)})):new Promise((n=>n(e._definition.call(t))))).then((function(t){if(e._version!==n)throw _r;if(function(e){return e&&"function"==typeof e.next&&"function"==typeof e.return}(t))return(r||Mr(e)).then((i=t,function(){i.return()})),function(e,t,n){const r=e._module._runtime;let i;function o(e){return new Promise((e=>e(n.next(i)))).then((({done:t,value:n})=>t?void 0:Promise.resolve(n).then(e)))}function s(){const n=o((o=>{if(e._version!==t)throw _r;return i=o,a(o,n).then((()=>r._precompute(s))),e._fulfilled(o),o}));n.catch((r=>{r!==_r&&e._version===t&&(a(void 0,n),e._rejected(r))}))}function a(t,n){return e._value=t,e._promise=n,e._outputs.forEach(r._updates.add,r._updates),r._compute()}return o((n=>{if(e._version!==t)throw _r;return i=n,r._precompute(s),n}))}(e,n,t);var i;return t}));i.then((t=>{e._value=t,e._fulfilled(t)}),(t=>{t!==_r&&(e._value=void 0,e._rejected(t))}))}function qr(e,t){e._invalidate(),e._invalidate=hr,e._pending(),++e._version,e._indegree=NaN,(e._promise=Promise.reject(t)).catch(hr),e._value=void 0,e._rejected(t)}function Ur(e){return globalThis[e]}Object.defineProperties(jr.prototype,{_precompute:{value:function(e){this._precomputes.push(e),this._compute()},writable:!0,configurable:!0},_compute:{value:function(){return this._computing||(this._computing=this._computeSoon())},writable:!0,configurable:!0},_computeSoon:{value:function(){return new Promise(Nr).then((()=>this._disposed?void 0:this._computeNow()))},writable:!0,configurable:!0},_computeNow:{value:async function(){let e,t,n=[],r=this._precomputes;if(r.length){this._precomputes=[];for(const e of r)e();await function(e=0){let t=Promise.resolve();for(let n=0;n<e;++n)t=t.then((()=>{}));return t}(3)}e=new Set(this._dirty),e.forEach((function(t){t._inputs.forEach(e.add,e);const n=function(e){if(e._observer!==yr)return!0;const t=new Set(e._outputs);for(const e of t){if(e._observer!==yr)return!0;e._outputs.forEach(t.add,t)}return!1}(t);n>t._reachable?this._updates.add(t):n<t._reachable&&t._invalidate(),t._reachable=n}),this),e=new Set(this._updates),e.forEach((function(t){t._reachable?(t._indegree=0,t._outputs.forEach(e.add,e)):(t._indegree=NaN,e.delete(t))})),this._computing=null,this._updates.clear(),this._dirty.clear(),e.forEach((function(e){e._outputs.forEach(Or)}));do{for(e.forEach((function(e){0===e._indegree&&n.push(e)}));t=n.pop();)Dr(t),t._outputs.forEach(i),e.delete(t);e.forEach((function(t){Rr(t)&&(qr(t,new lr("circular definition")),t._outputs.forEach(Pr),e.delete(t))}))}while(e.size);function i(e){0==--e._indegree&&n.push(e)}},writable:!0,configurable:!0},dispose:{value:function(){this._computing=Promise.resolve(),this._disposed=!0,this._variables.forEach((e=>{e._invalidate(),e._version=NaN}))},writable:!0,configurable:!0},module:{value:function(e,t=hr){let n;if(void 0===e)return(n=this._init)?(this._init=null,n):new kr(this);if(n=this._modules.get(e),n)return n;this._init=n=new kr(this),this._modules.set(e,n);try{e(this,t)}finally{this._init=null}return n},writable:!0,configurable:!0},fileAttachments:{value:function(e){return Object.assign((t=>{const n=e(t+="");if(null==n)throw new Error(`File not found: ${t}`);if("object"==typeof n&&"url"in n){const{url:e,mimeType:r}=n;return new On(e,t,r)}return new On(n,t)}),{prototype:On.prototype})},writable:!0,configurable:!0}}),jr.prototype.fileAttachments((function(e){return e}));const Br="dependencies",Fr=Symbol("dependencies"),Hr=Symbol("load"),zr=Promise.resolve(!0),Wr=new Map;function Gr(e){let t="undefined"!=typeof HTMLElement&&e instanceof HTMLElement?e.constructor:e;for(;t&&!Object.hasOwn(t,Br);)if(t=Object.getPrototypeOf(t),t&&"HTMLElement"===t.name)return null;return t}function Vr(e){const t=Gr(e);if(!t)return zr;const n=t[Fr]||(t[Fr]={});if(n[Hr])return n[Hr];const r={main:[],css:[]},i=t[Br];return i.forEach((({name:t,version:n,main:i,css:o})=>{const s=function(e,t){return n=>`https://cdn.jsdelivr.net/npm/${e}@${t}/${n}`}(t,n),a=s(i),l=s(o),c=Wr.get(a)||ht(a);Wr.set(a,c),r.main.push(c),o&&!Wr.has(l)&&(Wr.set(l,!0),r.css.push(function(e,t=globalThis.document){return new Promise((function(n,r){const i=t.createElement("link");i.rel="stylesheet",i.href=e,i.onerror=r,i.onload=n,t.head.appendChild(i)}))}(l,e.ownerDocument)))})),n[Hr]=Promise.all(r.main.concat(r.css)).then((e=>{const n=i.reduce(((t,n,r)=>(t[n.name]=e[r],t)),{});!function(e,t){const n=Gr(e);if(n){const e=n[Fr]||(n[Fr]={});for(const n in t)e[n]=t[n];e[Hr]=zr}}(t,n)}))}class Jr extends ne{getDependency(e){return function(e,t){return Gr(e)?.[Fr]?.[t]}(this,e)}shouldUpdate(){return!!function(e){const t=Gr(e);return!t||t[Fr]?.[Hr]===zr}(this)||(Vr(this).then((()=>{this.requestUpdate()})),!1)}}class Yr extends Jr{static get dependencies(){return[{name:"katex",version:"0.15.3",module:"dist/katex.mjs",main:"dist/katex.min.js",css:"dist/katex.min.css"}]}static get properties(){return{mode:{type:String},code:{type:String},maug:{type:String},leqno:{type:Boolean},fleqn:{type:Boolean,converter:e=>"false"!==e},minRuleThickness:{type:Number}}}constructor(){super(),this.mode="display",this.leqno=!1,this.fleqn=!1}initialChildNodes(e){!this.hasAttribute("code")&&e.length&&(this.code=e[0].textContent)}addAugmentations(){let e=this.maug||this.code;for(let t=0;t<this.definitions.length;t++){const{replace:n,symbol:r}=this.definitions[t];e=e.replaceAll(n,`\\htmlClass{maug maug-${t}}{${r}}`)}return e}prepareMath(){return this.definitions||(this.definitions=this.articleData()?.definitions||[]),this.addAugmentations()}render(){const e=this.getDependency("katex");if(!e||!this.code)return;const t="display"===this.mode,n={throwOnError:!1,displayMode:t,leqno:this.leqno,fleqn:this.fleqn,minRuleThickness:this.minRuleThickness,trust:({command:e})=>"\\htmlClass"===e,strict:e=>"htmlExtension"===e?"ignore":"warn"},r=document.createElement(t?"div":"span"),i=this.prepareMath();e.render(i,r,n);const o=r.querySelectorAll(".enclosing");for(const e of o){const t=[...e.classList].find((e=>e.startsWith("maug-"))).slice("maug-".length),{color:n}=this.definitions[+t];e.style.color=n}return setTimeout((()=>{for(const t of o)this.renderMaug(e,t)}),200),r}renderMaug(e,t){let n=t.parentNode;for(;n&&n!==this;)n.classList.add(".maug-parent"),n=n.parentNode;const r=[...t.classList].find((e=>e.startsWith("maug-"))).slice("maug-".length);let{symbol:i,definition:o}=this.definitions[+r];i=i.replaceAll("@",""),o=o.replaceAll("@","");const s=document.createElement("span");s.className="maug-tooltip",e.render(`${i}:\\text{${o}}`,s,{throwOnError:!1,displayMode:!1,leqno:this.leqno,fleqn:this.fleqn,minRuleThickness:this.minRuleThickness}),t.appendChild(s),t.setAttribute("tabindex",0),t.addEventListener("focusout",(()=>{s.style.display="none"})),t.addEventListener("keydown",(e=>{"Enter"==e.key?(s.style.display="inline-block",e.stopImmediatePropagation()):"Escape"==e.key&&(s.style.display="none")})),t.addEventListener("click",(e=>{s.style.display="inline-block",e.stopImmediatePropagation()}));const a=t.getBoundingClientRect(),l=s.getBoundingClientRect(),c=-a.width/2-l.width/2-12;s.style.transform=`translate(${c}px, -40px)`,s.appendChild(function(e,t){const n=document.createElementNS("http://www.w3.org/2000/svg","svg"),r=document.createElementNS("http://www.w3.org/2000/svg","line"),i=document.createElementNS("http://www.w3.org/2000/svg","circle"),o=Math.min(e.left,t.left),s=Math.max(e.right,t.right),a=t.bottom,l=e.top,c=o-t.right+5,u=t.height-1;n.setAttribute("style",`\n    min-width: ${s-o}px;\n    max-width: ${s-o}px;\n    height: ${l-a+3}px;\n    transform: translate(${c}px, ${u}px);\n  `);const d=e.left+e.width/2-o,h=l-a-2;return i.setAttribute("cx",d),i.setAttribute("cy",h),i.setAttribute("r",2),r.setAttribute("stroke","black"),r.setAttribute("stroke-width","1px"),r.setAttribute("x1",d),r.setAttribute("y1",h),r.setAttribute("x2",t.x+t.width/2-o),r.setAttribute("y2",0),n.appendChild(r),n.appendChild(i),n}(a,s.getBoundingClientRect())),s.style.display="none"}}document.querySelector("article").__data={citations:{bibtex:["@inproceedings{Baker1980,\n\tauthor = {Baker, H. Harlyn},\n\tbooktitle = {DARPA {Image} {Understanding} {Workshop}},\n\tyear = {1980},\n\tpages = {168--175},\n\ttitle = {Edge {Based} {Stereo} {Correlation}},\n}","@article{Barnea1972,\n\tauthor = {Barnea, Daniel I. and Silverman, Harvey F.},\n\tjournal = {IEEE Transactions on Computers},\n\tyear = {1972},\n\tpages = {179--186},\n\ttitle = {A {Class} of {Algorithms} for {Fast} {Digital} {Image} {Registration}},\n\tvolume = {C-21},\n}","@book{Dudewicz1976,\n\tauthor = {Dudewicz, Edward J.},\n\tyear = {1976},\n\tpublisher = {Holt, Rinehart},\n\ttitle = {Introduction to statistics and probability},\n}","@inproceedings{Gennery1979,\n\tauthor = {Gennery, Donald B},\n\tbooktitle = {DARPA {Image} {Understanding} {Workshop}},\n\tyear = {1979},\n\tpages = {101--107},\n\ttitle = {Stereo-{Camera} {Calibration}},\n}","@article{Marr1979,\n\tauthor = {Marr, D. and Poggio, Tomaso A.},\n\tjournal = {Proceedings of the Royal Society of London. Series B, Biological sciences},\n\tyear = {1979},\n\tpages = {301--328},\n\ttitle = {A computational theory of human stereo vision},\n\tvolume = {204 1156},\n}","@inproceedings{Moravec1979,\n\tauthor = {Moravec, Hans P.},\n\tbooktitle = {IJCAI},\n\tyear = {1979},\n\ttitle = {Visual {Mapping} by a {Robot} {Rover}},\n}","@inproceedings{Nilsson1971,\n\tauthor = {Nilsson, Nils J.},\n\tbooktitle = {McGraw-{Hill} computer science series},\n\tyear = {1971},\n\ttitle = {Problem-solving methods in artificial intelligence},\n}"],csl:[{author:[{given:"H. Harlyn",family:"Baker"}],"container-title":"DARPA Image Understanding Workshop",type:"paper-conference",id:"Baker1980","citation-key":"Baker1980",issued:{"date-parts":[[1980]]},page:"168-175",title:"Edge Based Stereo Correlation"},{"container-title":"IEEE Transactions on Computers",author:[{given:"Daniel I.",family:"Barnea"},{given:"Harvey F.",family:"Silverman"}],DOI:"10.1109/TC.1972.5008923",type:"article-journal",id:"Barnea1972","citation-key":"Barnea1972",issued:{"date-parts":[[1972]]},page:"179-186",title:"A Class of Algorithms for Fast Digital Image Registration",volume:"C-21"},{author:[{given:"Edward J.",family:"Dudewicz"}],type:"book",id:"Dudewicz1976","citation-key":"Dudewicz1976",issued:{"date-parts":[[1976]]},publisher:["Holt, Rinehart","Winston"],title:"Introduction to statistics and probability"},{author:[{given:"Donald B",family:"Gennery"}],"container-title":"DARPA Image Understanding Workshop",type:"paper-conference",id:"Gennery1979","citation-key":"Gennery1979",issued:{"date-parts":[[1979]]},page:"101-107",title:"Stereo-Camera Calibration"},{"container-title":"Proceedings of the Royal Society of London. Series B, Biological sciences",author:[{given:"D.",family:"Marr"},{given:"Tomaso A.",family:"Poggio"}],DOI:"10.1016/B978-1-4832-1446-7.50046-7",type:"article-journal",id:"Marr1979","citation-key":"Marr1979",issued:{"date-parts":[[1979]]},page:"301-328",title:"A computational theory of human stereo vision",volume:"204 1156"},{author:[{given:"Hans P.",family:"Moravec"}],"container-title":"IJCAI",DOI:"10.5555/1624861.1624997",type:"paper-conference",id:"Moravec1979","citation-key":"Moravec1979",issued:{"date-parts":[[1979]]},title:"Visual Mapping by a Robot Rover"},{author:[{given:"Nils J.",family:"Nilsson"}],"container-title":"McGraw-Hill computer science series",DOI:"10.1145/1056578.1056583",type:"paper-conference",id:"Nilsson1971","citation-key":"Nilsson1971",issued:{"date-parts":[[1971]]},title:"Problem-solving methods in artificial intelligence"}],data:[{id:"Baker1980",year:1980,author:[{given:"H. Harlyn",family:"Baker"}],title:"Edge Based Stereo Correlation",venue:"DARPA Image Understanding Workshop"},{id:"Barnea1972",doi:"10.1109/TC.1972.5008923",s2id:"e6b0088219fa42ec6a04560421540d2518ba004c",year:1972,author:[{given:"Daniel I.",family:"Barnea"},{given:"Harvey F.",family:"Silverman"}],title:"A Class of Algorithms for Fast Digital Image Registration",venue:"IEEE Transactions on Computers",url:"https://www.semanticscholar.org/paper/e6b0088219fa42ec6a04560421540d2518ba004c",abstract:"The automatic determination of local similarity between two structured data sets is fundamental to the disciplines of pattern recognition and image processing. A class of algorithms, which may be used to determine similarity in a far more efficient manner than methods currently in use, is introduced in this paper. There may be a saving of computation time of two orders of magnitude or more by adopting this new approach. The problem of translational image registration, used for an example throughout, is discussed and the problems with the most widely used method-correlation explained. Simple implementations of the new algorithms are introduced to motivate the basic idea of their structure. Real data from ITOS-1 satellites are presented to give meaningful empirical justification for theoretical predictions.",tldr:"A class of algorithms, which may be used to determine similarity in a far more efficient manner than methods currently in use, is introduced in this paper and may be a saving of computation time of two orders of magnitude or more by adopting this new approach."},{id:"Dudewicz1976",year:1976,author:[{given:"Edward J.",family:"Dudewicz"}],title:"Introduction to statistics and probability"},{id:"Gennery1979",year:1979,author:[{given:"Donald B",family:"Gennery"}],title:"Stereo-Camera Calibration",venue:"DARPA Image Understanding Workshop"},{id:"Marr1979",doi:"10.1016/B978-1-4832-1446-7.50046-7",s2id:"94645777d9ace911a1be34c7147c52bce1a17534",year:1979,author:[{given:"D.",family:"Marr"},{given:"Tomaso A.",family:"Poggio"}],title:"A computational theory of human stereo vision",venue:"Proceedings of the Royal Society of London. Series B, Biological sciences",url:"https://www.semanticscholar.org/paper/94645777d9ace911a1be34c7147c52bce1a17534",tldr:"It is shown that this proposal provides a theoretical framework for most existing psychophysical and neurophysiological data about stereopsis and several critical experimental predictions are also made, for instance about the size of Panum's area under various conditions."},{id:"Moravec1979",doi:"10.5555/1624861.1624997",year:1979,author:[{given:"Hans P.",family:"Moravec"}],title:"Visual Mapping by a Robot Rover",venue:"IJCAI"},{id:"Nilsson1971",doi:"10.1145/1056578.1056583",s2id:"099c7a0ec8900658838e7721bbf2ae289d205d62",year:1971,author:[{given:"Nils J.",family:"Nilsson"}],title:"Problem-solving methods in artificial intelligence",venue:"McGraw-Hill computer science series",url:"https://www.semanticscholar.org/paper/099c7a0ec8900658838e7721bbf2ae289d205d62",abstract:"This book is not a survey on theorem proving programs, but the description of a program developed from 1960 to 1965. In the first part there are some generalities on artificial intelligence, and in the second part, some logical explanations, necessary for the comprehension of the program. The third part describes the program. The program has three important features:-it is general. It can study more than one formal system. It receives as data the inference rules and the axioms of the formal system which it must study.-it is capable of invention. It can work without knowing the theorem to be proven. It tries to find interesting theorems; it has only the definition of the interest of a theorem.-it proves theorems, but also metatheorems which are new productions and meta-metatheorems which are new means to get productions. This feature has a great heuristic value. This textbook explains the theoretical ideas underlying problem-solving by heuristically guided, trial-and-error search processes. These search methods are explained by the use of a uniform vocabulary, and several theoretical results about the properties of heuristic search are presented. Several simple example problems, puzzles, and games are used to illustrate the techniques. The author refers to instances in which these same techniques have been successfully applied to problems much more complex than the example problems in his book. The book also includes three chapters that deal with resolution-based theorem-proving in the predicate calculus and its applications to problem solving. Each chapter contains exercises and a section on bibliographical and historical remarks that list some of the more important references related to the subject of the chapter.",tldr:"This book is not a survey on theorem proving programs, but the description of a program developed from 1960 to 1965, and includes three chapters that deal with resolution-based theorem-proving in the predicate calculus and its applications to problem solving."}]},definitions:[{replace:"@F(@x + @h)",symbol:"F(@x + @h)",color:"blue",definition:"Best translated $@F(x)$ to approximate $@G(x)$"},{replace:"@F(x + @h)",symbol:"F(x + @h)",color:"blue",definition:"Best translated $@F(x)$ to approximate $@G(x)$"},{replace:"d(x, @h)",symbol:"d(x, @h)",color:"darkblue",definition:"contribution of pixel $@x$ at disparity $@h$ to the total error"},{replace:"@F''(x)",symbol:"F''(x)",color:"darkslateblue",definition:"Derivative of $@F'(x)$"},{replace:"@\\alpha",symbol:"\\alpha",color:"violet",definition:"contrast adjustment"},{replace:"@F'(x)",symbol:"F'(x)",color:"darkblue",definition:"Linear approximation of $@F(x)$ in the neighborhood of $@x$"},{replace:"@G'(x)",symbol:"G'(x)",color:"darkolivegreen",definition:"Derivative of $@G(x)$"},{replace:"@\\beta",symbol:"\\beta",color:"rebeccapurple",definition:"brightness adjustment"},{replace:"@F(x)",symbol:"F(x)",color:"blue",definition:"First stereo image"},{replace:"@G(x)",symbol:"G(x)",color:"darkgreen",definition:"Second stereo image"},{replace:"@w(x)",symbol:"w(x)",color:"darkred",definition:"weighting function"},{replace:"@F''",symbol:"F''",color:"darkslateblue",definition:"Derivative of $@F'(x)$"},{replace:"@F'",symbol:"F'",color:"darkblue",definition:"Linear approximation of $@F(x)$ in the neighborhood of $@x$"},{replace:"@G'",symbol:"G'",color:"darkolivegreen",definition:"Derivative of $@G(x)$"},{replace:"@@x",symbol:"x",color:"red",definition:"position of image in camera 1 film plane"},{replace:"@@G",symbol:"G",color:"darkgreen",definition:"intensity value of pixel in picture 1"},{replace:"@@F",symbol:"F",color:"blue",definition:"intensity value of pixel in picture 2"},{replace:"@h",symbol:"h",color:"purple",definition:"disparity vector"},{replace:"@x",symbol:"x",color:"red",definition:"position vector in an image"},{replace:"@F",symbol:"F",color:"blue",definition:"First stereo image"},{replace:"@G",symbol:"G",color:"darkgreen",definition:"Second stereo image"},{replace:"@R",symbol:"R",color:"orange",definition:"Region of interest"},{replace:"@N",symbol:"N",color:"sienna",definition:"Size of picture $@G(x)$"},{replace:"@M",symbol:"M",color:"sienna",definition:"Size of the region of possible values of $@h$"},{replace:"@A",symbol:"A",color:"darkred",definition:"matrix representing linear transformation between $@F(x)$ and $@G(x)$"},{replace:"@z",symbol:"z",color:"violet",definition:"distance of object"},{replace:"@p",symbol:"p",color:"darkolivegreen",definition:"object's position on camera 1's film plane"},{replace:"@q",symbol:"q",color:"darkblue",definition:"object's position on camera 2's film plane"},{replace:"@c",symbol:"c",color:"rebeccapurple",definition:"vector of camera 2's parameters with respect to camera 1"},{replace:"@E",symbol:"E",color:"darkred",definition:"Error to minimize"}]},window.customElements.define("cite-ref",class extends re{static get properties(){return{key:{type:String},mode:{type:String},index:{type:Number}}}constructor(){super(),this.mode="citation"}initialChildNodes(e){this.__prefix=e[0],this.__suffix=e[1]}citeData(){return this.data||(this.data=this.articleData()?.citations?.data[this.index-1])}render(){const{key:e,index:t,mode:n,data:r=this.citeData()}=this,i="cite-ref"+(r?"":" unresolved"),o=null==r?t??"??":"inline-author"===n?function(e,t,n=2){const{author:r,title:i}=e;if(!r||!r.length)return`${i} [${t}]`;let o=r[0].family;2===r.length?o+=` & ${r[1].family}`:r.length>n&&(o+=" et al.");return`${o} [${t}]`}(r,t):t;return this.renderWithTooltip(i,o,function(e,t){return t?I`<div class="cite-info">
      ${function(e){const{url:t,title:n,year:r,author:i}=e,o=r?I`\u2022 <span class="cite-year">${r}</a>`:"",s=n||se(i).join(", ")||"Unknown Title";return t?I`<div class="cite-title">
      <a href=${t} target="_blank" rel="noopener noreferrer">${s}</a>
      ${o}
    </div>`:I`<div class="cite-title">${s}${o}</div>`}(t)}
      ${function(e,t=4){const{author:n,title:r}=e;if(!r)return null;const i=se(n),o=i.length-t;if(o>1){const e=i.slice(0,t).join(", "),n=", "+i.slice(t).join(", "),r=I`<span class="cite-author-button" @click=${ae}>+${o}&nbsp;authors</span>`,s=I`<span class="cite-author-expand"> ${r}</span>`,a=I` <span class="cite-author-button" @click=${le}>less</span>`,l=I`<span class="cite-author-hidden">${n}${a}</span>`;return I`<div class="cite-author">${e}${s}${l}</div>`}return i.length?I`<div class="cite-author">${i.join(", ")}</div>`:null}(t)}
      ${function(e){const{venue:t}=e;return t?I`<div class="cite-venue">${t}</div>`:null}(t)}
      ${function(e,t=300){const{abstract:n,tldr:r}=e,i=r||n;if(!i)return null;const o=i!==r&&i.length>t?i.slice(0,i.slice(0,t).lastIndexOf(" "))+"…":i;return I`<div class="cite-detail">${o}</div>`}(t)}
    </div>`:I`<div class="cite-info">
      <strong>Unresolved citation</strong><br>"${e}"
    </div>`}(e,r))}}),window.customElements.define("cross-ref",class extends re{static get properties(){return{type:{type:String},xref:{type:String},index:{type:Number},short:{type:Boolean}}}show(){this.renderTooltipContent(),super.show()}goto(e){e.preventDefault();const t=`#${this.xref}`;history.replaceState(null,null,t),document.querySelector(t).scrollIntoView({behavior:"smooth",block:"nearest"})}renderTooltipContent(){if(null==this.index)return;const e=this.querySelector(".cross-ref-tooltip");e.replaceChildren(),ue(e,document.getElementById(this.xref)),e.firstElementChild.className=this.type===de.FIGURE?"figure":this.type===de.TABLE?"table":""}renderUnresolvedReference(e){const t=I`<div class="cross-ref-tooltip">
      Unresolved ${this.type} reference: ${this.xref}
    </div>`;return this.renderWithTooltip(`${e} unresolved`,"?",t)}renderResolvedReference(e){if(this.type===de.SECTION)return this.removeEventListener("keydown",this.keyDown),this.removeEventListener("mousedown",this.mouseDown),I`<a class=${e} href="#${this.xref}" @click=${this.goto}>${this.index}</a>`;{const t=I`<div class="cross-ref-tooltip"></div>`;return this.renderWithTooltip(e,this.index,t)}}renderWithTooltip(e,t,n){const r=I`<div class="tooltip">${n}</div>`;return I`<span class=${e} @dblclick=${this.goto} tabindex=0>${r}${t}</span>`}render(){const{type:e,index:t,short:n}=this,r=`cross-ref ${e}${n?"":" full"}`;return null!=t?this.renderResolvedReference(r):this.renderUnresolvedReference(r)}}),window.customElements.define("tex-equation",class extends Yr{static get properties(){return{type:{type:String},nonumber:{type:Boolean},definitions:{type:Array}}}constructor(){super(),this.mode="display",this.type="align",this.nonumber=!1}prepareMath(){const e=this.type+(this.nonumber?"*":"");return`\\begin{${e}}\n${super.prepareMath()}\n\\end{${e}}`}}),window.customElements.define("tex-math",Yr),window.addEventListener("DOMContentLoaded",(()=>{!function(e){let t=[...e.querySelectorAll(".sticky")].map((t=>({sticky:t,inMargin:t.classList.contains("margin"),end:e.querySelector(t.getAttribute("sticky-through"))||e.querySelector(t.getAttribute("sticky-until")),untilBottom:null!=t.getAttribute("sticky-through")})));for(const{sticky:e}of t.filter((({end:e})=>!e)))console.log(e,"Could not find sticky anchor "+(e.getAttribute("sticky-through")||e.getAttribute("sticky-until"))),e.classList.remove("sticky");t=t.filter((({end:e})=>e)),window.addEventListener("scroll",(()=>{let e=[];const n=!window.matchMedia("(max-width: 1100px)").matches;for(const{sticky:r,inMargin:i,end:o,untilBottom:s}of t){if(!o)continue;const t=r.getBoundingClientRect(),a=t.top+window.scrollY-+r.style.transform.slice("translateY(".length,-"px)".length);let l=o.offsetTop;s&&(l+=o.offsetHeight);let c=l-(a+t.height);c=Math.min(0,c);let u=a+c,d=u+t.height;for(const[o,s,h]of e){if(n&&i!=h||d<=o||u>=s)continue;let e=Math.max(0,s+t.height-l);c=s-a-e,u=s-e,d=u+t.height,r.style.setProperty("z-index",1)}e.push([u,d,i]),r.style.setProperty("transform",`translateY(${c}px)`)}}),{passive:!0})}(document.querySelector("article"))}));

    </script>
</html>